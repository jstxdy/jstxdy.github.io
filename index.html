<!DOCTYPE html>
<html lang="cn">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>North-Box</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="NorthBox">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<div id="page">

<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/cover.jpeg)">
  <div class="overlay">
  <div class="featured">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>NorthBox</span>
    <h1>North-Box</h1>
    
    
  </div>
  </div>
</div>

<div id="lx-main-content">
  <div class="lx-post">

  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/08/06/MVC/">JAVA后端学习规划</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-08-06</span>
      <p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="学习关键："><a href="#学习关键：" class="headerlink" title="学习关键："></a>学习关键：</h2><p>Spring 核心是 <font color='navyblue'>IoC 容器</font>，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。<br>理解好 IoC 后，接下来是面向<font color='navyblue'>切面编程（AOP）</font>，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。<br>其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，</p>
<h2 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h2><details>
<summary>应用程序</summary>能完成我们所需要功能的成品，比如购物网站、OA 系统。
</details>
<details>
<summary>框架</summary>能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。
</details>
<details>
<summary>非侵入式设计</summary>从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。
</details>
<details>
<summary>轻量级与重量级</summary>轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。
</details>
<details>
<summary>POJO</summary>Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。
</details>
<details>
<summary>容器</summary>在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。
</details>
<details>
<summary>控制反转</summary>即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。
</details>
<details>
<summary>Bean</summary>一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象.
</details>

<h2 id="Spring优点："><a href="#Spring优点：" class="headerlink" title="Spring优点："></a>Spring优点：</h2><p>Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。</p>
<details>
<summary>非常轻量级的容器</summary>以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。
</details>
<details>
<summary>AOP</summary>AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），_即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术_。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。
</details>
<details>
<summary>简单的数据库事务管理</summary>在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。
</details>
<details>
<summary>JDBC 抽象及 ORM（对象关系映射）框架支持</summary>Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。
</details>
<details>
<summary>灵活的 Web 层支持</summary>Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。
</details>
<details>
<summary>简化各种技术集成</summary>提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。
</details></p>
      <div class="post-button"><a class="btn" href="/2020/08/06/MVC/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/31/JSP/">JSP</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-31</span>
      <p><p>#JSP代码</p>
<pre><code>&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;  pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot;%&gt;</code></pre><p>是JSP的&lt;%@page指令</p>
<pre><code>contentType=&quot;text/html; charset=UTF-8&quot; </code></pre><p>相当于response.setContentType(“text/html; charset=UTF-8”); 通知浏览器以UTF-8进行中文解码</p>
<pre><code>pageEncoding=&quot;UTF-8&quot; </code></pre><p>如果jsp文件中出现了中文，这些中文使用UTF-8进行编码</p>
<pre><code>import=&quot;java.util.* </code></pre><p>导入其他类，如果导入多个类，彼此用,逗号隔开，像这样 import=”java.util.<em>,java.sql.</em>“</p>
<h1 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h1><p>jsp由这些页面元素组成：</p>
<ol>
<li>静态内容<br>就是html,css,javascript等内容</li>
<li>指令<br>以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=”java.util.*”%&gt;</li>
<li>表达式 &lt;%=%&gt;<br>用于输出一段html</li>
<li>Scriptlet<br>在&lt;%%&gt; 之间，可以写任何java 代码</li>
<li>声明<br>在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。</li>
<li>动作<br>&lt;jsp:include page=”Filename” &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解</li>
<li>注释 &lt;%– – %&gt;<br>不同于 html的注释 <!-- --> 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了</li>
</ol>
<h2 id="lt-gt-和-lt-out-println-gt"><a href="#lt-gt-和-lt-out-println-gt" class="headerlink" title="&lt;%=%&gt;和 &lt;%out.println()%&gt;"></a>&lt;%=%&gt;和 &lt;%out.println()%&gt;</h2><pre><code>&lt;%=&quot;hello jsp&quot;%&gt; =&lt;%out.println(&quot;hello jsp&quot;);%&gt;</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><blockquote>
<p>for.jsp</p>
</blockquote>
<h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a>INCLUDE</h2><p>用来存放版权声明等信息。<br>如果不使用包含，那么每个网页都需要单独写，如果版权声明要修改，则需要很大的工作量。</p>
<p>使用include的办法，只需要准备一个footer.jsp，然后在其他页面包含footer.jsp即可。<br>修改的时候，只需要修改footer.jsp所有的页面就都修改了，维护成本降低了很多。</p>
<p>include有两种方式指令include和动作include</p>
<blockquote>
<p>footer.jsp<br>Hello.jsp</p>
</blockquote>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>指令&lt;%@include 会导致两个jsp合并成为同一个java文件，所以就不存在传参的问题，在发出hello.jsp 里定义的变量，直接可以在footer.jsp中访问。</p>
<p>动作&lt;jsp:include /&gt;其实是对footer.jsp进行了一次独立的访问，那么就有传参的需要。</p>
<p> &lt;jsp:include page=”footer.jsp”&gt;<br>    &lt;jsp:param  name=”year” value=”2017” /&gt;<br> </jsp:include><br> //在footer.jsp中，使用request.getParameter(“year”)取出year<br> <hr><br>    <p style="text-align:center">copyright@&lt;%=request.getParameter(“year”)%&gt;<br> </p></p>
<h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><h2 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h2><p>sp的客户端跳转和Servlet中是一样的。</p>
<p> &lt;%<br>    response.sendRedirect(“hello.jsp”);<br> %&gt;</p>
<h2 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h2><p>与Servlet的服务端跳转一样，也可以使用</p>
<pre><code>request.getRequestDispatcher(&quot;hello.jsp&quot;).forward(request, response);
//或者简化代码
&lt;jsp:forward page=&quot;hello.jsp&quot;/&gt;</code></pre><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="cookie介绍"><a href="#cookie介绍" class="headerlink" title="cookie介绍"></a>cookie介绍</h2><p>有的网站，登陆的时候，会出现一个选项，问你是否要一周内或者一个月内保持登陆状态。<br>如果你选了，那么一周之内，都不需要再输入账号密码。<br>这个功能，就是靠cookie来实现的</p>
<h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>Cookie是一种浏览器和服务器交互数据的方式。Cookie是由服务器端创建，但是不会保存在服务器。<br>创建好之后，发送给浏览器。浏览器保存在用户本地。下一次访问网站的时候，就会把该Cookie发送给服务器。</p>
<blockquote>
<p>setCookie.jsp<br>getCookie.jsp</p>
</blockquote>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="https://stepimagewm.how2j.cn/1675.png" alt=""></p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h2 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h2><p>Session会话指的是从用户打开浏览器访问一个网站开始，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。 直到该用户关闭浏览器为止，都属于同一个会话。</p>
<blockquote>
<p>setSession.jsp<br>getSession.jsp</p>
</blockquote>
<h2 id="Session-和Cookie的区别"><a href="#Session-和Cookie的区别" class="headerlink" title="Session 和Cookie的区别"></a>Session 和Cookie的区别</h2><p>A和B都有自己的盒子，那么他们怎么知道哪个盒子是自己的呢？<br>通过钥匙就能找到自己的盒子了。</p>
<p>盒子对应服务器上的Session。<br>钥匙对应浏览器上的Cookie。</p>
<h2 id="Session-原理示意图"><a href="#Session-原理示意图" class="headerlink" title="Session 原理示意图"></a>Session 原理示意图</h2><p><img src="https://stepimagewm.how2j.cn/1673.png" alt=""></p>
<h2 id="如果没有cookie，session如何工作"><a href="#如果没有cookie，session如何工作" class="headerlink" title="如果没有cookie，session如何工作"></a>如果没有cookie，session如何工作</h2><p>如果浏览器把cookie功能关闭，那么服务端就无法获取jsessionid,每一次访问，都会生成一个新的session对象。</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” import=”javax.servlet.http.Cookie”%&gt;</p>
<p> &lt;%<br>   session.setAttribute(“name”, “teemo”);<br> //response.encodeURL方法会把getSession.jsp这个url转换为<br> getSession.jsp;jsessionid=22424AEA86ADBE89F335EEB649D997A8<br> //通过这个方式，提交jsessionid到服务器。 服务器根据这个jsessionid匹配到对应的session. 与session相关的功能，就可以正常工作了。</p>
<p> %&gt;<br> &lt;a href=”&lt;%=response.encodeURL(“getSession.jsp”)%&gt;”&gt;跳转到获取session的页面</a></p>
<h2 id="session的有效期"><a href="#session的有效期" class="headerlink" title="session的有效期"></a>session的有效期</h2><p>比如登录一个网站，登录后，在短时间内，依然可以继续访问而不用重新登录。<br>但是较长时间不登录，依然会要求重新登录，这是因为服务端的session在一段时间不使用后，就失效了。</p>
<p>这个时间，在Tomcat默认配置下，是30分钟。</p>
<p>可以通过 tomcat/conf/web.xml 中的session-config 配置进行调整</p>
<h1 id="四种作用域"><a href="#四种作用域" class="headerlink" title="四种作用域"></a>四种作用域</h1><p>SP有4个作用域，分别是<br>pageContext 当前页面<br>requestContext 一次请求<br>sessionContext 当前会话<br>applicationContext 全局，所有用户共享  </p>
<h2 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h2><p>准备setContext.jsp和getContext.jsp，分别表示向作用域设置数据，和从作用域获取数据。</p>
<p>pageContext表示当前页面作用域</p>
<p>通过pageContext.setAttribute(key,value)的数据，只能在当前页面访问，在其他页面就不能访问了。</p>
<blockquote>
<p>setContext.jsp<br>getContext.jsp</p>
</blockquote>
<h2 id="requestContext"><a href="#requestContext" class="headerlink" title="requestContext"></a>requestContext</h2><p>requestContext 表示一次请求。随着本次请求结束，其中的数据也就被回收。</p>
<pre><code>request.setAttribute(&quot;name&quot;,&quot;gareen&quot;); 
request.getAttribute(&quot;name&quot;)</code></pre><h2 id="requestContext与服务端跳转"><a href="#requestContext与服务端跳转" class="headerlink" title="requestContext与服务端跳转"></a>requestContext与服务端跳转</h2><p>requestContext指的是一次请求<br>如果发生了服务端跳转，从setContext.jsp跳转到getContext.jsp，这其实，还是一次请求。 所以在getContext.jsp中，可以取到在requestContext中设置的值</p>
<h2 id="requestContext与客户端跳转"><a href="#requestContext与客户端跳转" class="headerlink" title="requestContext与客户端跳转"></a>requestContext与客户端跳转</h2><p>客户端跳转，浏览器会发生一次新的访问，新的访问会产生一个新的request对象。<br>所以页面间客户端跳转的情况下，是无法通过request传递数据的。</p>
<h2 id="sessionContext"><a href="#sessionContext" class="headerlink" title="sessionContext"></a>sessionContext</h2><p>sessionContext 指的是会话，从一个用户打开网站的那一刻起，无论访问了多少网页，链接都属于同一个会话，直到浏览器关闭。<br>所以页面间传递数据，也是可以通过session传递的。<br>但是，不同用户对应的session是不一样的，所以session无法在不同的用户之间共享数据。</p>
<p>与requestContext类似的，也可以用如下方式来做</p>
<pre><code>pageContext.setAttribute(&quot;name&quot;,&quot;gareen&quot;,pageContext.SESSION_SCOPE);
pageContext.getAttribute(&quot;name&quot;,pageContext.SESSION_SCOPE)</code></pre><h2 id="applicationContext"><a href="#applicationContext" class="headerlink" title="applicationContext"></a>applicationContext</h2><p>applicationContext 指的是全局，所有用户共享同一个数据</p>
<p>在JSP中使用application对象， application对象是ServletContext接口的实例<br>也可以通过 request.getServletContext()来获取。<br>所以 application == request.getServletContext() 会返回true<br>application映射的就是web应用本身。</p>
<p>与requestContext类似的，也可以用如下方式来做</p>
<pre><code>pageContext.setAttribute(&quot;name&quot;,&quot;gareen&quot;,pageContext.APPLICATION_SCOPE);
pageContext.getAttribute(&quot;name&quot;,pageContext.APPLICATION_SCOPE)</code></pre><h1 id="九种隐式对象"><a href="#九种隐式对象" class="headerlink" title="九种隐式对象"></a>九种隐式对象</h1><p>JSP的隐式对象指的是不需要显示定义，直接就可以使用的对象，比如request,response</p>
<p>JSP一共有9个隐式对象，分别是request,response,outpageContext, session,applicationpage,config,exception</p>
<p>request 代表请求<br>response 代表响应<br>out 代表 输出<br>pageContext 代表当前页面作用域<br>session 代表当会话作用域<br>application 代表当全局作用域<br>page 对象即表示当前对象：JSP 会被编译为一个Servlet类 ，运行的时候是一个Servlet实例。 page即代表this</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>config可以获取一些在web.xml中初始化的参数。<br>在JSP中使用config比较复杂，需要如下几个步骤</p>
<ol>
<li>在web.xml中进行配置</li>
<li>创建一个testconfig.jsp<br>通过config.getInitParameter(“database-ip”) 获取参数</li>
<li>访问路径，获取web.xml中配置的参数</li>
</ol>
<h2 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h2><p>exception 对象只有当前页面的&lt;%@page 指令设置为isErrorPage=”true”的时候才可以使用。<br>同时，在其他页面也需要设置 &lt;%@page 指令 errorPage=”” 来指定一个专门处理异常的页面。</p>
<ol>
<li><p>准备一个try.jsp<br>设置errorPage=”catch.jsp”，表示有异常产生的话，就交给catch.jsp处理<br>故意在里面造成数组越界异常</p>
</li>
<li><p>准备一个catch.jsp<br>设置 isErrorPage=”true”，表示当前页面可以使用exception对象</p>
</li>
</ol>
<h1 id="JSTL-JSP-Standard-Tag-Library-标准标签库"><a href="#JSTL-JSP-Standard-Tag-Library-标准标签库" class="headerlink" title="JSTL JSP Standard Tag Library 标准标签库"></a>JSTL JSP Standard Tag Library 标准标签库</h1><p>JSTL允许开人员可以像使用HTML标签 那样在JSP中开发Java功能。<br>JSTL库有core, i18n, fmt, sql 等等。<br>i18n和sql用的很少，core和fmt在工作中会用到，本章节主要讲解core和fmt</p>
<h2 id="set-out-remove"><a href="#set-out-remove" class="headerlink" title="set out remove"></a>set out remove</h2><p>在页面中使用JSTL需要在jsp中通过指令进行设置<br>prefix=”c” 表示后续的标签使用都会以&lt;c: 开头</p>
<pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</code></pre><p>在作用域request中设置name,相当于&lt;%request.setAttribute(“name”,”gareen”)%&gt;</p>
<pre><code>&lt;c:set var=&quot;name&quot; value=&quot;${&apos;gareen&apos;}&quot; scope=&quot;request&quot; /&gt;
&lt;c:out value=&quot;${name}&quot; /&gt;  //相当于 &lt;%=request.getAttribute(&quot;name&quot;)%&gt;
&lt;c:remove var=&quot;name&quot; scope=&quot;request&quot; /&gt;  //相当于&lt;%request.removeAttribute(&quot;name&quot;)%&gt;在作用域request中删掉name</code></pre><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>JSTL通过&lt;c:if test=””&gt; 进行条件判断，但是JSTL没有&lt;c:else，所以常用的办法是在&lt;c:if的条件里取反<br>配合if使用的还有通过empty进行为空判断<br>empty可以判断对象是否为null,字符串长度是否为0，集合长度是否为0  </p>
<h2 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h2><p>虽然JSTL没有提供else标签，但是提供了一个else功能的标签</p>
<pre><code>&lt;c:choose&gt;
    &lt;c:when test=&quot;${hp&lt;5}&quot;&gt;
        ...
    &lt;/c:when&gt;
    &lt;c:otherwise&gt;
        ...
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;</code></pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>可以在JSP中使用for循环，但是其可读性很差。 借助JSTL的c:forEach标签，可以改善可读性</p>
<p>在本例中，分别使用for循环和&lt;c:forEach标签来演示遍历一个List的区别</p>
<pre><code>&lt;c:forEach items=&quot;${heros}&quot; var=&quot;hero&quot; varStatus=&quot;st&quot;  &gt;
//items=&quot;${heros}&quot; 表示遍历的集合
//var=&quot;hero&quot; 表示把每一个集合中的元素放在hero上
//varStatus=&quot;st&quot; 表示遍历的状态</code></pre><h2 id="forTokens"><a href="#forTokens" class="headerlink" title="forTokens"></a>forTokens</h2><p>&lt;c:forTokens专门用于字符串拆分，并且可以指定多个分隔符</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” import=”java.util.*”%&gt;</p>
<p> &lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;</p>
<p> &lt;c:set var=”heros” value=”塔姆,艾克;巴德|雷克赛!卡莉丝塔” /&gt;</p>
<p> &lt;c:forTokens items=”${heros}” delims=”:;|!” var=”hero”&gt;<br>    &lt;c:out value=”${hero}” /&gt; <br /><br> </c:forTokens></p>
<h2 id="fmt-formatNumber-格式化数字"><a href="#fmt-formatNumber-格式化数字" class="headerlink" title="fmt:formatNumber 格式化数字"></a>fmt:formatNumber 格式化数字</h2><p> fmt 标签常用来进行格式化，其中fmt:formatNumber用于格式化数字<br>使用之前要加上</p>
<pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&apos;fmt&apos; %&gt;  
&lt;fmt:formatNumber type=&quot;number&quot; value=&quot;${money}&quot; minFractionDigits=&quot;2&quot;/&gt;</code></pre><p>&lt;fmt:formatNumber 表示格式化数字<br>minFractionDigits 小数点至少要有的位数<br>maxFractionDigits 小数点最多能有的位数</p>
<h2 id="fmt-formatDate-格式化日期"><a href="#fmt-formatDate-格式化日期" class="headerlink" title="fmt:formatDate 格式化日期"></a>fmt:formatDate 格式化日期</h2><p>fmt 标签常用来进行格式化，其中fmt:formatDate 用于格式化日期<br>和fmt:formatNumber 格式化数字一样，使用之前要加上</p>
<pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&apos;fmt&apos; %&gt;  </code></pre><p>&lt;fmt:formatDate 表示格式化日期<br>yyyy 表示年份<br>MM 表示月份<br>dd 表示日期<br>E 表示星期几<br>a 表示是上午还是下午<br>HH 表示小时<br>mm 表示分钟<br>ss 表示秒<br>S 表示毫秒<br>z 表示时区<br>    &lt;fmt:formatDate value=”${now}” pattern=”G yyyy年MM月dd日 E”/&gt;<br>    &lt;fmt:formatDate value=”${now}” pattern=”a HH:mm:ss.S z”/&gt;<br>    &lt;fmt:formatDate value=”${now}” pattern=”yyyy-MM-dd HH:mm:ss”/&gt;</p>
<h2 id="fn"><a href="#fn" class="headerlink" title="fn:"></a>fn:</h2><p>fn标签提供各种实用功能，首先使用之前使用加入如下指令</p>
<pre><code>&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; </code></pre><details><summary>fn函数</summary>
fn:contains(string, substring)

<p>如果参数string中包含参数substring，返回true</p>
<p>fn:containsIgnoreCase(string, substring)</p>
<p>如果参数string中包含参数substring（忽略大小写），返回true</p>
<p>fn:endsWith(string, suffix)</p>
<p>如果参数 string 以参数suffix结尾，返回true</p>
<p>fn:escapeXml(string)</p>
<p>将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回</p>
<p>fn:indexOf(string, substring)</p>
<p>返回参数substring在参数string中第一次出现的位置</p>
<p>fn:join(array, separator)</p>
<p>将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。</p>
<p>fn:length(item)</p>
<p>返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。</p>
<p>fn:replace(string, before, after)</p>
<p>返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果</p>
<p>fn:split(string, separator)</p>
<p>返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素</p>
<p>fn:startsWith(string, prefix)</p>
<p>如果参数string以参数prefix开头，返回true</p>
<p>fn:substring(string, begin, end)</p>
<p>返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符</p>
<p>fn:substringAfter(string, substring)</p>
<p>返回参数substring在参数string中后面的那一部分字符串</p>
<p>fn:substringBefore(string, substring)</p>
<p>返回参数substring在参数string中前面的那一部分字符串</p>
<p>fn:toLowerCase(string)</p>
<p>将参数string所有的字符变为小写，并将其返回</p>
<p>fn:toUpperCase(string)</p>
<p>将参数string所有的字符变为大写，并将其返回</p>
<p>fn:trim(string)</p>
<p>去除参数string 首尾的空格，并将其返回</p>
</details>

<h1 id="EL表达式语言"><a href="#EL表达式语言" class="headerlink" title="EL表达式语言"></a>EL表达式语言</h1><p>为了保证EL表达式能够正常使用，需要在&lt;%@page 标签里加上isELIgnored=”false”</p>
<p>使用EL表达式，非常简单比如使用JSTL输出要写成</p>
<pre><code>&lt;c:out value=&quot;${name}&quot; /&gt; </code></pre><p>但是用EL只需要</p>
<pre><code>${name}</code></pre><p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” isELIgnored=”false”%&gt;<br> &lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;<br> &lt;c:set var=”name” value=”${‘gareen’}” scope=”request” /&gt;</p>
<p> 通过标签获取name: &lt;c:out value=”${name}” /&gt; <br><br> 通过 EL 获取name: ${name}</p>
<h2 id="作用域优先级"><a href="#作用域优先级" class="headerlink" title="作用域优先级"></a>作用域优先级</h2><p>EL表达式可以从pageContext,request,session,application四个作用域中取到值，如果4个作用域都有name属性怎么办？</p>
<p>EL会按照从高到低的优先级顺序获取<br>pageContext&gt;request&gt;session&gt;application</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” isELIgnored=”false”%&gt;<br> &lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;</p>
<p> &lt;c:set var=”name” value=”${‘gareen-pageContext’}” scope=”page” /&gt;<br> &lt;c:set var=”name” value=”${‘gareen-request’}” scope=”request” /&gt;<br> &lt;c:set var=”name” value=”${‘gareen-session’}” scope=”session” /&gt;<br> &lt;c:set var=”name” value=”${‘gareen-application’}” scope=”application” /&gt;<br>4个作用域都有name,优先获取出来的是 ： ${name}</p>
<h2 id="JavaBean概念"><a href="#JavaBean概念" class="headerlink" title="JavaBean概念"></a>JavaBean概念</h2><p>EL可以很方便的访问JavaBean的属性，那么JavaBean是什么呢？</p>
<p>JavaBean的标准</p>
<ol>
<li>提供无参public的构造方法(默认提供)</li>
<li>每个属性，都有public的getter和setter</li>
<li>如果属性是boolean,那么就对应is和setter方法</li>
</ol>
<p>比如示例代码中的Hero类，默认提供了一个无参的public的构造方法。 同时每个属性都有getter和setter</p>
<p>package bean;<br>public class Hero {<br>    public int id;<br>    public String name;<br>    public float hp;<br>    public int damage;<br>    public int getId() {<br>        return id;<br>    }<br>    public void setId(int id) {<br>        this.id = id;<br>    }<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public float getHp() {<br>        return hp;<br>    }<br>    public void setHp(float hp) {<br>        this.hp = hp;<br>    }<br>    public int getDamage() {<br>        return damage;<br>    }<br>    public void setDamage(int damage) {<br>        this.damage = damage;<br>    }<br> }</p>
<h2 id="获取JavaBean的属性"><a href="#获取JavaBean的属性" class="headerlink" title="获取JavaBean的属性"></a>获取JavaBean的属性</h2><p>获取JavaBean的属性，只需要通过.符号操作就可以了。<br>像这样 ${hero.name} ，就会自动调用getName方法了<br>注： 如果属性是boolean类型，那么就会自动调用isXXX方法了</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” isELIgnored=”false” import=”bean.*”%&gt;<br> &lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;<br> &lt;%<br>    Hero hero =new Hero();<br>    hero.setName(“盖伦”);<br>    hero.setHp(616);<br>    request.setAttribute(“hero”, hero);<br> %&gt;<br> 英雄名字 ： ${hero.name} <br><br> 英雄血量 ： ${hero.hp}</p>
<h2 id="结合JSTL的-lt-c-forEach"><a href="#结合JSTL的-lt-c-forEach" class="headerlink" title="结合JSTL的&lt;c:forEach"></a>结合JSTL的&lt;c:forEach</h2><p>EL还可以结合 JSTL的&lt;c:forEach 使用，进一步简化代码<br>原代码中的&lt;c:out value=”${hero}” /&gt;<br>可以简写为${hero}</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” import=”java.util.*”%&gt;<br> &lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;<br> &lt;%<br>    List<String> heros = new ArrayList<String>();<br>    heros.add(“塔姆”);<br>    heros.add(“艾克”);<br>    heros.add(“巴德”);<br>    heros.add(“雷克赛”);<br>    heros.add(“卡莉丝塔”);<br>    request.setAttribute(“heros”,heros);<br> %&gt;<br> <table width="200px" align="center" border="1" cellspacing="0"><br> <tr><br>    <td>编号</td><br>    <td>英雄</td><br> </tr><br> &lt;c:forEach items=”${heros}” var=”hero” varStatus=”st”  &gt;<br>    <tr><br>        <td>${st.count}</td><br>        <td>${hero}</td><br>    </tr><br> </c:forEach><br> </table></p>
<h2 id="取参"><a href="#取参" class="headerlink" title="取参"></a>取参</h2><p>EL表达式还可以做到request.getParameter(“name”) 这样的形式获取浏览器传递过来的参数<br>先把jstl.jsp代码改为如例所示，然后访问如下地址<br><a href="http://127.0.0.1/jstl.jsp?name=abc可以观察到获取了参数" target="_blank" rel="noopener">http://127.0.0.1/jstl.jsp?name=abc可以观察到获取了参数</a> name</p>
<p> &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8” import=”java.util.*” isELIgnored=”false”%&gt;<br> ${param.name}</p>
<h2 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h2><p>进行条件判断，大大简化了 JSTL的 c:if 和 c:choose 代码<br>如例，一行代码就能起到其他好几行代码的效果<br>${killNumber ge 10? “超神”:”还没超神” }</p>
<blockquote>
<p>eq.jsp</p>
</blockquote>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/31/JSP/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/19/J2EE-TOMCAT/">TOMCAT</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-19</span>
      <p><h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<h2 id="Servlet-通过调用-init-方法进行初始化。"><a href="#Servlet-通过调用-init-方法进行初始化。" class="headerlink" title="Servlet 通过调用 init () 方法进行初始化。"></a>Servlet 通过调用 init () 方法进行初始化。</h2><pre><code>public void init() throws ServletException {
// 初始化代码...
}</code></pre><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>
<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>
<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
<blockquote>
<p>Servlet.java</p>
</blockquote>
<p><img src="https://stepimagewm.how2j.cn/1594.png" alt="avatar"><br><img src="https://stepimagewm.how2j.cn/1595.png" alt="avatar"></p>
<h2 id="Servlet-调用-service-方法来处理客户端的请求。"><a href="#Servlet-调用-service-方法来处理客户端的请求。" class="headerlink" title="Servlet 调用 service() 方法来处理客户端的请求。"></a>Servlet 调用 service() 方法来处理客户端的请求。</h2><pre><code>public void service(ServletRequest request, 
                ServletResponse response) 
  throws ServletException, IOException{
}</code></pre><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可。</p>
<h3 id="–-doGet-方法"><a href="#–-doGet-方法" class="headerlink" title="– doGet() 方法"></a>– doGet() 方法</h3><pre><code>public void doGet(HttpServletRequest request,
              HttpServletResponse response)
throws ServletException, IOException {
// Servlet 代码
}</code></pre><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>
<h3 id="–-doPost-方法"><a href="#–-doPost-方法" class="headerlink" title="– doPost() 方法"></a>– doPost() 方法</h3><pre><code>public void doPost(HttpServletRequest request,
               HttpServletResponse response)
throws ServletException, IOException {
// Servlet 代码
}</code></pre><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>
<h2 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h2><pre><code>public void destroy() {
// 终止化代码...
}</code></pre><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。<br>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。</p>
<p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。  </p>
<h1 id="Servlet-表单数据"><a href="#Servlet-表单数据" class="headerlink" title="Servlet 表单数据"></a>Servlet 表单数据</h1><p>很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。</p>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。</p>
<p>这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。</p>
<pre><code>http://www.test.com/hello?key1=value1&amp;key2=value2</code></pre><h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。</p>
<h2 id="使用-Servlet-读取表单数据"><a href="#使用-Servlet-读取表单数据" class="headerlink" title="使用 Servlet 读取表单数据"></a>使用 Servlet 读取表单数据</h2><p>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：</p>
<p>getParameter()：您可以调用 request.getParameter() 方法来获取表单参数的值。<br>getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。<br>getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。  </p>
<h3 id="Get和Post方法传递表单数据"><a href="#Get和Post方法传递表单数据" class="headerlink" title="Get和Post方法传递表单数据"></a>Get和Post方法传递表单数据</h3><blockquote>
<p>HelloForm.java<br>Hello.html</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><blockquote>
<p>CheckBox.java<br>CheckBox.html</p>
</blockquote>
<h2 id="读取所有的表单参数"><a href="#读取所有的表单参数" class="headerlink" title="读取所有的表单参数"></a>读取所有的表单参数</h2><p>使用 HttpServletRequest 的 getParameterNames() 方法读取所有可用的表单参数。该方法返回一个枚举，其中包含未指定顺序的参数名。</p>
<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 hasMoreElements() 方法来确定何时停止，使用 nextElement() 方法来获取每个参数的名称。</p>
<h1 id="如何进行服务端跳转和客户端跳转"><a href="#如何进行服务端跳转和客户端跳转" class="headerlink" title="如何进行服务端跳转和客户端跳转"></a>如何进行服务端跳转和客户端跳转</h1><p>首先在web目录下准备两个页面 success.html,fail.html<br>分别用于显示登录成功 或者登录失败</p>
<p>如果登录成功了，就服务端跳转到success.html<br>如果登录失败了，就客户端跳转到fail.html</p>
<blockquote>
<p>SkipSuccess.html<br>SkipFail.html</p>
</blockquote>
<h2 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h2><pre><code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></pre><p>服务端跳转可以看到浏览器的地址依然是/login 路径，并不会变成success.html</p>
<blockquote>
<p><img src="https://stepimagewm.how2j.cn/1568.png" alt="avatar"></p>
</blockquote>
<h2 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h2><pre><code>response.sendRedirect(&quot;fail.html&quot;);</code></pre><p>可以观察到，浏览器地址发生了变化</p>
<blockquote>
<p><img src="https://stepimagewm.how2j.cn/1567.png" alt="avatar"></p>
</blockquote>
<h1 id="自启动配置"><a href="#自启动配置" class="headerlink" title="自启动配置"></a>自启动配置</h1><pre><code>//在web.xml中，配置Hello Servlet的地方，增加一句
&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;</code></pre><p>取值范围是1-99，即表明该Servlet会随着Tomcat的启动而初始化。</p>
<p>同时，为HelloServlet提供一个init(ServletConfig) 方法，验证自启动<br>在tomcat完全启动之前，就打印了init of HelloServlet<br><load-on-startup>10</load-on-startup> 中的10表示启动顺序<br>如果有多个Servlet都配置了自动启动，数字越小，启动的优先级越高</p>
<h1 id="REQUEST常见方法"><a href="#REQUEST常见方法" class="headerlink" title="REQUEST常见方法"></a>REQUEST常见方法</h1><p>request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”<br>request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名”<br>request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br>request.getRemoteAddr(): 浏览器所处于的客户机的IP地址<br>request.getRemoteHost(): 浏览器所处于的客户机的主机名<br>request.getRemotePort(): 浏览器所处于的客户机使用的网络端口<br>request.getLocalAddr(): 服务器的IP地址<br>request.getLocalName(): 服务器的主机名<br>request.getMethod(): 得到客户机请求方式一般是GET或者POST</p>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p>request.getParameter(): 是常见的方法，用于获取单值的参数<br>request.getParameterValues(): 用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。<br>request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。</p>
<blockquote>
<p>ReadParams.html<br>ReadParams.java<br>结果在服务端显示</p>
</blockquote>
<h2 id="获取头信息"><a href="#获取头信息" class="headerlink" title="获取头信息"></a>获取头信息</h2><p>request.getHeader() 获取浏览器传递过来的头信息。<br>比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器<br>request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p>
<p>头信息:<br>host: 主机地址<br>user-agent: 浏览器基本资料<br>accept: 表示浏览器接受的数据类型<br>accept-language: 表示浏览器接受的语言<br>accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码<br>connection: 是否保持连接<br>cache-control: 缓存时限  </p>
<blockquote>
<p>GetHeader.java</p>
</blockquote>
<h1 id="RESPONSE常见用法"><a href="#RESPONSE常见用法" class="headerlink" title="RESPONSE常见用法"></a>RESPONSE常见用法</h1><h2 id="设置响应内容"><a href="#设置响应内容" class="headerlink" title="设置响应内容"></a>设置响应内容</h2><p>通过response.getWriter(); 获取一个PrintWriter 对象<br>可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。</p>
<pre><code>//doGet()
        PrintWriter pw= response.getWriter();
        pw.println(&quot;&lt;h1&gt;Hello Servlet&lt;/h1&gt;&quot;);</code></pre><h2 id="设置响应格式"><a href="#设置响应格式" class="headerlink" title="设置响应格式"></a>设置响应格式</h2><p>“text/html” 是即格式 ，在request获取头信息 中对应的request.getHeader(“accept”).<br>“text/html” 是存在的，表示浏览器可以识别这种格式，如果换一个其他的格式， 比如 “text/lol” ，浏览器不能识别，那么打开此servlet就会弹出一个下载的对话框。</p>
<pre><code>//response.setContentType(&quot;text/html&quot;);
response.setContentType(&quot;text/lol&quot;);</code></pre><h2 id="设置响应编码"><a href="#设置响应编码" class="headerlink" title="设置响应编码"></a>设置响应编码</h2><p>设置响应编码有两种方式:</p>
<pre><code>//不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文
response.setContentType(&quot;text/html; charset=UTF-8&quot;);

//仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。
response.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre><h2 id="301或者302客户端跳转"><a href="#301或者302客户端跳转" class="headerlink" title="301或者302客户端跳转"></a>301或者302客户端跳转</h2><pre><code>//302 表示临时跳转,302就是前面在客户端跳转章节用到过的
response.sendRedirect(&quot;fail.html&quot;);

//301 表示永久性跳转,301要使用另外的手段：
response.setStatus(301);
response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;);</code></pre><h2 id="设置不使用缓存"><a href="#设置不使用缓存" class="headerlink" title="设置不使用缓存"></a>设置不使用缓存</h2><p>使用缓存可以加快页面的加载，降低服务端的负担。但是也可能看到过时的信息，可以通过如下手段通知浏览器不要使用缓存</p>
<pre><code>//doGet()
response.setDateHeader(&quot;Expires&quot;,0 );
response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);</code></pre><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><h2 id="上传页面-upload-html"><a href="#上传页面-upload-html" class="headerlink" title="上传页面 upload.html"></a>上传页面 upload.html</h2><pre><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;form action=&quot;uploadPhoto&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
……
&lt;/form&gt;</code></pre><h2 id="在UploadPhotoServlet进行上传的功能开发。"><a href="#在UploadPhotoServlet进行上传的功能开发。" class="headerlink" title="在UploadPhotoServlet进行上传的功能开发。"></a>在UploadPhotoServlet进行上传的功能开发。</h2><p>前部分代码是固定写法，用来做一些准备工作。 直到遍历出Item,一个Item就是对应一个浏览器提交的数据，通过item.getInputStream可以打开浏览器上传的文件的输入流。</p>
<p>客户提交的文件名有可能是一样的，所以在服务端保存文件的时候，不能使用客户提交的文件名。这里使用的是一种粗糙的解决文件名重复的办法，即使用时间戳。</p>
<p>读取输入流中的数据，保存在服务端的目录下，这个目录是通过getRealPath获取到的。 如果项目部署在其他地方，那么会自动做相应的变化。<br>注： 为什么要放这里？ 因为后续网页上显示的时候是通过<a href="http://127.0.0.1/uploaded/xxx.jpg" target="_blank" rel="noopener">http://127.0.0.1/uploaded/xxx.jpg</a> 路径来获取图片。</p>
<p>根据临时生成的文件名，创建一个html img元素，然后通过response返回浏览器</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/19/J2EE-TOMCAT/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/15/JAVA-Swing/">图形界面</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-15</span>
      <p><h1 id="一个简单的-SWING-例子"><a href="#一个简单的-SWING-例子" class="headerlink" title="一个简单的 SWING 例子"></a>一个简单的 SWING 例子</h1><p><font color='navyblue'>GUI:</font>Graphic User Interface 图形用户界面</p>
<p>JFrame是GUI中的容器<br>JButton是最常见的组件- 按钮<br>注意：f.setVisible(true); 会对所有的组件进行渲染，所以一定要放在最后面</p>
<h1 id="SWING-如何进行事件监听"><a href="#SWING-如何进行事件监听" class="headerlink" title="SWING 如何进行事件监听"></a>SWING 如何进行事件监听</h1><h2 id="按钮监听"><a href="#按钮监听" class="headerlink" title="按钮监听"></a>按钮监听</h2><p>创建一个匿名类实现ActionListener接口，当按钮被点击时，actionPerformed方法就会被调用</p>
<pre><code>//匿名类实现ActionListener接口
b.addActionListener(new ActionListener() {
    // 当按钮被点击时，就会触发 ActionEvent事件,actionPerformed 方法就会被执行
    public void actionPerformed(ActionEvent e) {
        l.setVisible(false);
    }
});</code></pre><h2 id="鼠标监听"><a href="#鼠标监听" class="headerlink" title="鼠标监听"></a>鼠标监听</h2><p>MouseListener 鼠标监听器<br>mouseReleased 鼠标释放<br>mousePressed 鼠标按下<br>mouseExited 鼠标退出<br>mouseEntered 鼠标进入<br>mouseClicked 鼠标点击<br>在本例中，使用mouseEntered，当鼠标进入图片的时候，图片就移动位置</p>
<details><summary>TestMouseListener.java</summary>

<pre><code>public class TestMouseListener {
public static void main(String[] args) {

    final JFrame f = new JFrame(&quot;LoL&quot;);
    f.setSize(800, 600);
    f.setLocationRelativeTo(null);
    f.setLayout(null);

    final JLabel l = new JLabel();
    ImageIcon i = new ImageIcon(&quot;C:\\Users\\LENOVO\\Pictures\\Camera Roll\\A.png&quot;);
    l.setIcon(i);
    l.setBounds(375, 275, i.getIconWidth(), i.getIconHeight());

    f.add(l);

    l.addMouseListener(new MouseListener() {
         public void mouseEntered(MouseEvent e) {

            Random r = new Random();

            int x = r.nextInt(f.getWidth() - l.getWidth());
            int y = r.nextInt(f.getHeight() - l.getHeight());

            l.setLocation(x, y);
        }
    });
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    f.setVisible(true);
}</code></pre></details>

<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p><font color='navyblue'>MouseAdapter</font>鼠标监听适配器,一般说来在写监听器的时候，会实现MouseListener。<br>但是MouseListener里面有很多方法实际上都没有用到，比如mouseReleased ，mousePressed，mouseExited等等。<br>这个时候就可以使用 鼠标监听适配器，MouseAdapter 只需要重写必要的方法即可。</p>
<details><summary>TestMosueAdapter.java</summary>
        // MouseAdapter 适配器，只需要重写用到的方法，没有用到的就不用写了
        l.addMouseListener(new MouseAdapter() {
            // 只有mouseEntered用到了
            public void mouseEntered(MouseEvent e) {

<pre><code>        Random r = new Random();

        int x = r.nextInt(f.getWidth() - l.getWidth());
        int y = r.nextInt(f.getHeight() - l.getHeight());

        l.setLocation(x, y);

    }
});</code></pre></details>

<h1 id="SWING-的容器-JFRAME和JDIALOG"><a href="#SWING-的容器-JFRAME和JDIALOG" class="headerlink" title="SWING 的容器 JFRAME和JDIALOG"></a>SWING 的容器 JFRAME和JDIALOG</h1><p>java的图形界面中，容器是用来存放 按钮，输入框等组件的。</p>
<p>窗体型容器有两个，一个是JFrame,一个是JDialog</p>
<h2 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h2><p>JFrame是最常用的窗体型容器，默认情况下，在右上角有最大化最小化按钮</p>
<p><img src="https://stepimagewm.how2j.cn/887.png" alt="avatar"></p>
<pre><code>public static void main(String[] args) {
    //普通的窗体，带最大和最小化按钮
    JFrame f = new JFrame(&quot;LoL&quot;);
    f.setSize(400, 300);
    f.setLocation(200, 200);
    f.setLayout(null);
    JButton b = new JButton(&quot;一键秒对方基地挂&quot;);
    b.setBounds(50, 50, 280, 30);

    f.add(b);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    f.setVisible(true);
}</code></pre><h2 id="JDialog"><a href="#JDialog" class="headerlink" title="JDialog"></a>JDialog</h2><p>JDialog也是窗体型容器，右上角没有最大和最小化按钮</p>
<p><img src="https://stepimagewm.how2j.cn/888.png" alt="avatar"></p>
<pre><code>public static void main(String[] args) { 
    //普通的窗体，带最大和最小化按钮，而对话框却不带
    JDialog d = new JDialog();
    d.setTitle(&quot;LOL&quot;);
    d.setSize(400, 300);
    d.setLocation(200, 200);
    d.setLayout(null);
    JButton b = new JButton(&quot;一键秒对方基地挂&quot;);
    b.setBounds(50, 50, 280, 30);

    d.add(b);

    d.setVisible(true);
}</code></pre><h2 id="模态JDialog"><a href="#模态JDialog" class="headerlink" title="模态JDialog"></a>模态JDialog</h2><p>当一个对话框被设置为模态的时候，其背后的父窗体，是不能被激活的，除非该对话框被关闭<br><img src="https://wx2.sinaimg.cn/mw690/c2af83c2ly1ggs4fa7mbxj20m80go0sv.jpg" alt="avatar"></p>
<details><summary>ModalJdialog.java</summary>

<pre><code>    public static void main(String[] args) {
    JFrame f = new JFrame(&quot;外部窗体&quot;);
    f.setSize(800, 600);
    f.setLocation(100, 100);

    // 根据外部窗体实例化JDialog
    JDialog d = new JDialog(f);
    // 设置为模态
    d.setModal(true);

    d.setTitle(&quot;模态的对话框&quot;);
    d.setSize(400, 300);
    d.setLocation(200, 200);
    d.setLayout(null);
    JButton b = new JButton(&quot;一键秒对方基地挂&quot;);
    b.setBounds(50, 50, 280, 30);
    d.add(b);

    f.setVisible(true);
    d.setVisible(true);
}</code></pre></details>

<h2 id="窗体大小不可变化"><a href="#窗体大小不可变化" class="headerlink" title="窗体大小不可变化"></a>窗体大小不可变化</h2><p>通过调用方法 <font color='orange'>setResizable(false)</font>做到窗体大小不可变化</p>
<pre><code>f.add(b);
// 窗体大小不可变化
f.setResizable(false);
f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

f.setVisible(true);</code></pre><h1 id="SWING五种常见的布局器"><a href="#SWING五种常见的布局器" class="headerlink" title="SWING五种常见的布局器"></a>SWING五种常见的布局器</h1><p>布局器是用在容器上的。用来决定容器上的组件摆放的位置和大小.</p>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>绝对定位就是指不使用布局器，组件的位置和大小需要单独指定</p>
<pre><code>JFrame f = new JFrame(&quot;LoL&quot;);
f.setSize(400, 300);
f.setLocation(200, 200);

// 设置布局器为null，即进行绝对定位，容器上的组件都需要指定位置和大小
f.setLayout(null);
JButton b1 = new JButton(&quot;英雄1&quot;);
// 指定位置和大小
b1.setBounds(50, 50, 80, 30);

// 没有指定位置和大小，不会出现在容器上
JButton b4 = new JButton(&quot;英雄3&quot;);

f.add(b1);
// b4没有指定位置和大小，不会出现在容器上
f.add(b4);</code></pre><h2 id="FlowLayout"><a href="#FlowLayout" class="headerlink" title="FlowLayout"></a>FlowLayout</h2><p>设置布局器为<font color='orange'>FlowLayout</font>顺序布局器,容器上的组件水平摆放,加入到容器即可，无需单独指定大小和位置</p>
<pre><code>f.setLayout(new FlowLayout());</code></pre><h2 id="BorderLayout"><a href="#BorderLayout" class="headerlink" title="BorderLayout"></a>BorderLayout</h2><p>设置布局器为<font color='orange'>BorderLayout</font>容器上的组件按照上北 下南 左西 右东 中的顺序摆放</p>
<pre><code>f.setLayout(new BorderLayout());

JButton b1 = new JButton(&quot;洪七&quot;);
JButton b2 = new JButton(&quot;段智兴&quot;);
JButton b3 = new JButton(&quot;欧阳锋&quot;);
JButton b4 = new JButton(&quot;黄药师&quot;);
JButton b5 = new JButton(&quot;周伯通&quot;);

// 加入到容器的时候，需要指定位置
f.add(b1, BorderLayout.NORTH);
f.add(b2, BorderLayout.SOUTH);
f.add(b3, BorderLayout.WEST);
f.add(b4, BorderLayout.EAST);
f.add(b5, BorderLayout.CENTER);</code></pre><h2 id="GridLayout"><a href="#GridLayout" class="headerlink" title="GridLayout"></a>GridLayout</h2><p>GridLayout，即网格布局器<br><img src="https://stepimagewm.how2j.cn/892.png" alt="avatar"></p>
<pre><code>// 该GridLayerout的构造方法表示该网格是2行3列
f.setLayout(new GridLayout(2, 3));

JButton b1 = new JButton(&quot;洪七&quot;);
JButton b2 = new JButton(&quot;段智兴&quot;);
JButton b3 = new JButton(&quot;欧阳锋&quot;);
JButton b4 = new JButton(&quot;黄药师&quot;);
JButton b5 = new JButton(&quot;周伯通&quot;);

f.add(b1);
f.add(b2);
f.add(b3);
f.add(b4);
f.add(b5);</code></pre><h2 id="setPreferredSize"><a href="#setPreferredSize" class="headerlink" title="setPreferredSize"></a>setPreferredSize</h2><p>即便 使用 布局器 ，也可以 通过setPreferredSize，向布局器建议该组件显示的大小.<br>注 只对部分布局器起作用，比如FlowLayout可以起作用。 比如GridLayout就不起作用，因为网格布局器必须对齐</p>
<p><img src="https://stepimagewm.how2j.cn/919.png" alt="avatar"></p>
<pre><code>f.setLayout(new FlowLayout());

JButton b1 = new JButton(&quot;英雄1&quot;);
JButton b2 = new JButton(&quot;英雄2&quot;);
JButton b3 = new JButton(&quot;英雄3&quot;);

// 即便 使用 布局器 ，也可以 通过setPreferredSize，向布局器建议该组件显示的大小
b3.setPreferredSize(new Dimension(180, 40));

f.add(b1);
f.add(b2);
f.add(b3);</code></pre><h2 id="CardLayout"><a href="#CardLayout" class="headerlink" title="CardLayout"></a>CardLayout</h2><p><img src="https://stepimagewm.how2j.cn/2734.png" alt="avatar"></p>
<h1 id="SWING-中的组件列表"><a href="#SWING-中的组件列表" class="headerlink" title="SWING 中的组件列表"></a>SWING 中的组件列表</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>Label用于显示文字</p>
<pre><code>JLabel l = new JLabel(&quot;LOL文字&quot;);
//文字颜色
l.setForeground(Color.red);
l.setBounds(50, 50, 280, 30);</code></pre><h2 id="使用JLabel显示图片"><a href="#使用JLabel显示图片" class="headerlink" title="使用JLabel显示图片"></a>使用JLabel显示图片</h2><p>java GUI 显示图片是通过在label上设置图标实现的<br>注： 这里的图片路径是e:/project/j2se/shana.png，所以要确保这里有图片，不然不会显示<br>注： 图片的后缀名和真实格式，必须保持一致，否则很有可能无法正常显示。 什么意思呢？就是文件本来是jpg的，但是仅仅是把后缀名修改成了png,那么会导致显示失败。</p>
<pre><code>JLabel l = new JLabel();
//根据图片创建ImageIcon对象
ImageIcon i = new ImageIcon(&quot;e:/project/j2se/shana.png&quot;);
//设置ImageIcon
l.setIcon(i);
//label的大小设置为ImageIcon,否则显示不完整
l.setBounds(50, 50, i.getIconWidth(), i.getIconHeight());</code></pre><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>JButton 普通按钮</p>
<pre><code>JButton b = new JButton(&quot;一键秒对方基地挂&quot;);
b.setBounds(50, 50, 280, 30);</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><p>JCheckBox 复选框,使用isSelected来获取是否选中了</p>
<pre><code>JCheckBox bCheckBox = new JCheckBox(&quot;物理英雄&quot;);
//设置 为 默认被选中
bCheckBox.setSelected(true);
bCheckBox.setBounds(50, 50, 130, 30);
JCheckBox bCheckBox2 = new JCheckBox(&quot;魔法 英雄&quot;);
bCheckBox2.setBounds(50, 100, 130, 30);
//判断 是否 被 选中
System.out.println(bCheckBox2.isSelected());
f.add(bCheckBox);
f.add(bCheckBox2);</code></pre><h2 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h2><p>JRadioButton 单选框,使用isSelected来获取是否选中了</p>
<p>在这个例子里，两个单选框可以被同时选中，为了实现只能选中一个，还需要用到ButtonGroup</p>
<pre><code>JRadioButton b1 = new JRadioButton(&quot;物理英雄&quot;);
// 设置 为 默认被选中
b1.setSelected(true);
b1.setBounds(50, 50, 130, 30);
JRadioButton b2 = new JRadioButton(&quot;魔法 英雄&quot;);
b2.setBounds(50, 100, 130, 30);
System.out.println(b2.isSelected());

f.add(b1);
f.add(b2);</code></pre><h2 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h2><p><font color='orange'>ButtonGroup</font>对按钮进行分组，把不同的按钮，放在同一个分组里 ，同一时间，只有一个 按钮 会被选中</p>
<pre><code>JRadioButton b1 = new JRadioButton(&quot;物理英雄&quot;);
b1.setSelected(true);
b1.setBounds(50, 50, 130, 30);
JRadioButton b2 = new JRadioButton(&quot;魔法 英雄&quot;);
b2.setBounds(50, 100, 130, 30);

// 按钮分组
ButtonGroup bg = new ButtonGroup();
// 把b1，b2放在 同一个 按钮分组对象里 ，这样同一时间，只有一个 按钮 会被选中
bg.add(b1);
bg.add(b2);

f.add(b1);
f.add(b2);</code></pre><h2 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h2><p>JComboBox 下拉框<br>使用getSelectedItem来获取被选中项<br>使用setSelectedItem() 来指定要选中项</p>
<pre><code>//下拉框出现的条目
String[] heros = new String[] { &quot;卡特琳娜&quot;, &quot;库奇&quot; };
JComboBox cb = new JComboBox(heros);

cb.setBounds(50, 50, 80, 30);

f.add(cb);</code></pre><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>JOptionPane 用于弹出对话框</p>
<p>JOptionPane.showConfirmDialog(f, “是否 使用外挂 ？”);表示询问，第一个参数是该对话框以哪个组件对齐<br>JOptionPane.showInputDialog(f, “请输入yes，表明使用外挂后果自负”);接受用户的输入<br>JOptionPane.showMessageDialog(f, “你使用外挂被抓住！ 罚拣肥皂3次！”);显示消息</p>
<pre><code>int option = JOptionPane.showConfirmDialog(f, &quot;是否 使用外挂 ？&quot;);
if (JOptionPane.OK_OPTION == option) {
    String answer = JOptionPane.showInputDialog(f, &quot;请输入yes，表明使用外挂后果自负&quot;);
    if (&quot;yes&quot;.equals(answer))
        JOptionPane.showMessageDialog(f, &quot;你使用外挂被抓住！ 罚拣肥皂3次！&quot;);
}</code></pre><h2 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h2><p>JTextField 输入框<br>setText 设置文本<br>getText 获取文本<br>JTextField 是单行文本框，如果要输入多行数据，请使用JTextArea  </p>
<p>tfPassword.grabFocus(); 表示让密码输入框获取焦点</p>
<pre><code>f.setLayout(new FlowLayout());

JLabel lName = new JLabel(&quot;账号：&quot;);
// 输入框
JTextField tfName = new JTextField(&quot;&quot;);
tfName.setText(&quot;请输入账号&quot;);
tfName.setPreferredSize(new Dimension(80, 30));

JLabel lPassword = new JLabel(&quot;密码：&quot;);
// 输入框
JTextField tfPassword = new JTextField(&quot;&quot;);
tfPassword.setText(&quot;请输入密码&quot;);
tfPassword.setPreferredSize(new Dimension(80, 30));

f.add(lName);
f.add(tfName);
f.add(lPassword);
f.add(tfPassword);

f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

f.setVisible(true);
tfPassword.grabFocus();</code></pre><h2 id="密码框"><a href="#密码框" class="headerlink" title="密码框"></a>密码框</h2><p>JPasswordField 密码框<br>与文本框不同，获取密码框里的内容，推荐使用getPassword，该方法会返回一个字符数组，而非字符串</p>
<pre><code>f.setLayout(new FlowLayout());
JLabel l = new JLabel(&quot;密码：&quot;);
// 密码框
JPasswordField pf = new JPasswordField(&quot;&quot;);
pf.setText(&quot;&amp;48kdh4@#&quot;);
pf.setPreferredSize(new Dimension(80, 30));

// 与文本框不同，获取密码框里的内容，推荐使用getPassword，该方法会返回一个字符数组，而非字符串
char[] password = pf.getPassword();
String p = String.valueOf(password);
System.out.println(p);

f.add(l);
f.add(pf);</code></pre><h2 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h2><p>JTextArea：文本域。和文本框JTextField不同的是，文本域可以输入多行数据<br>如果要给文本域初始文本，通过\n来实现换行效果<br>JTextArea通常会用到append来进行数据追加,如果文本太长，会跑出去，可以通过setLineWrap(true) 来做到自动换行</p>
<pre><code>f.setLayout(new FlowLayout());

JLabel l = new JLabel(&quot;文本域：&quot;);
JTextArea ta = new JTextArea();
ta.setPreferredSize(new Dimension(200, 150));
//\n换行符
ta.setText(&quot;抢人头！\n抢你妹啊抢！\n&quot;);
//追加数据
ta.append(&quot;我去送了了了了了了了了了了了了了了了了了了了了了了了了&quot;);
//设置自动换行
ta.setLineWrap(true);

f.add(l);
f.add(ta);</code></pre><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><p><img src="https://stepimagewm.how2j.cn/2703.png" alt="avatar"></p>
<pre><code>f.setLayout(new FlowLayout());
JProgressBar pb = new JProgressBar();
//进度条最大100
pb.setMaximum(100);
//当前进度是50
pb.setValue(50);
//显示当前进度
pb.setStringPainted(true);

f.add(pb);</code></pre><h2 id="文件选择器"><a href="#文件选择器" class="headerlink" title="文件选择器"></a>文件选择器</h2><p>JFileChooser 表示文件选择器,使用FileFilter用于仅选择.txt文件  </p>
<p>fc.showOpenDialog(); 用于打开文件<br>fc.showSaveDialog(); 用于保存文件</p>
<pre><code>f.setLayout(new FlowLayout());
JFileChooser fc = new JFileChooser();
fc.setFileFilter(new FileFilter() {
    @Override
    public String getDescription() {
        // TODO Auto-generated method stub
        return &quot;.txt&quot;;
    } 
    @Override
    public boolean accept(File f) {
        return f.getName().toLowerCase().endsWith(&quot;.txt&quot;);
    }
});
JButton bOpen = new JButton(&quot;打开文件&quot;);
JButton bSave = new JButton(&quot;保存文件&quot;);
f.add(bOpen);
f.add(bSave);
f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
f.setSize(250, 150);
f.setLocationRelativeTo(null);
f.setVisible(true);
bOpen.addActionListener(new ActionListener() { 
    @Override
    public void actionPerformed(ActionEvent e) {
         int returnVal =  fc.showOpenDialog(f);
         File file = fc.getSelectedFile();
         if (returnVal == JFileChooser.APPROVE_OPTION) {
             JOptionPane.showMessageDialog(f, &quot;计划打开文件:&quot; + file.getAbsolutePath());
         }

    }
});
bSave.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        int returnVal =  fc.showSaveDialog(f);
        File file = fc.getSelectedFile();
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            JOptionPane.showMessageDialog(f, &quot;计划保存到文件:&quot; + file.getAbsolutePath());
        }
    }
});</code></pre><h1 id="SWING-四种常见面板"><a href="#SWING-四种常见面板" class="headerlink" title="SWING 四种常见面板"></a>SWING 四种常见面板</h1><h2 id="基本面板"><a href="#基本面板" class="headerlink" title="基本面板"></a>基本面板</h2><p>JPanel即为基本面板<br>面板和JFrame一样都是容器，不过面板一般用来充当中间容器，把组件放在面板上，然后再把面板放在窗体上。<br>一旦移动一个面板，其上面的组件，就会全部统一跟着移动，采用这种方式，便于进行整体界面的设计</p>
<p><img src="https://stepimagewm.how2j.cn/893.png" alt="avatar"></p>
<pre><code>JPanel p1 = new JPanel();
// 设置面板大小
p1.setBounds(50, 50, 300, 60);
// 设置面板背景颜色
p1.setBackground(Color.RED);
// 这一句可以没有，因为JPanel默认就是采用的FlowLayout
p1.setLayout(new FlowLayout());
JButton b1 = new JButton(&quot;英雄1&quot;);
JButton b2 = new JButton(&quot;英雄2&quot;);
JButton b3 = new JButton(&quot;英雄3&quot;);

// 把按钮加入面板
p1.add(b1);
p1.add(b2);
p1.add(b3);</code></pre><h2 id="ContentPane"><a href="#ContentPane" class="headerlink" title="ContentPane"></a>ContentPane</h2><p>JFrame上有一层面板，叫做ContentPane<br>平时通过f.add()向JFrame增加组件，其实是向JFrame上的 ContentPane加东西</p>
<pre><code>JButton b = new JButton(&quot;一键秒对方基地挂&quot;);
b.setBounds(50, 50, 280, 30);

f.add(b);
// JFrame上有一层面板，叫做ContentPane
// 平时通过f.add()向JFrame增加组件，其实是向JFrame上的 ContentPane加东西
// f.add等同于f.getContentPane().add(b);
f.getContentPane().add(b);

// b.getParent()获取按钮b所处于的容器
// 打印出来可以看到，实际上是ContentPane而非JFrame
System.out.println(b.getParent());</code></pre><h2 id="SplitPanel"><a href="#SplitPanel" class="headerlink" title="SplitPanel"></a>SplitPanel</h2><p>创建一个水平JSplitPane，左边是pLeft,右边是pRight</p>
<pre><code>// 创建一个水平JSplitPane，左边是p1,右边是p2
JSplitPane sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, pLeft, pRight);
// 设置分割条的位置
sp.setDividerLocation(80);

// 把sp当作ContentPane
f.setContentPane(sp);</code></pre><h2 id="JScrollPanel"><a href="#JScrollPanel" class="headerlink" title="JScrollPanel"></a>JScrollPanel</h2><p>使用带滚动条的面板有两种方式<br>1.在创建JScrollPane，把组件作为参数传进去 </p>
<pre><code>JScrollPane sp = new JScrollPane(ta);</code></pre><p>2.希望带滚动条的面板显示其他组件的时候，调用setViewportView</p>
<pre><code>sp.setViewportView(ta);</code></pre><p><img src="https://stepimagewm.how2j.cn/2721.png" alt="avatar"></p>
<pre><code>//准备一个文本域，在里面放很多数据
JTextArea ta = new JTextArea();
for (int i = 0; i &lt; 1000; i++) {
    ta.append(String.valueOf(i));
}
//自动换行
ta.setLineWrap(true);
JScrollPane sp = new JScrollPane(ta);

f.setContentPane(sp);</code></pre><h2 id="TabbedPanel"><a href="#TabbedPanel" class="headerlink" title="TabbedPanel"></a>TabbedPanel</h2><p><img src="https://stepimagewm.how2j.cn/896.png" alt="avatar"></p>
<pre><code>JTabbedPane tp = new JTabbedPane();
tp.add(p1);
tp.add(p2);

// 设置tab的标题
tp.setTitleAt(0, &quot;红色tab&quot;);
tp.setTitleAt(1, &quot;蓝色tab&quot;);

ImageIcon i = new ImageIcon(&quot;D:/Github/North-Box/B.png&quot;);
tp.setIconAt(0,i );
tp.setIconAt(1,i );

f.setContentPane(tp);</code></pre><h2 id="CardLayerout"><a href="#CardLayerout" class="headerlink" title="CardLayerout"></a>CardLayerout</h2><p>CardLayerout 布局器 很像TabbedPanel ，在本例里面上面是一个下拉框，下面是一个CardLayerout 的JPanel<br>这个JPanel里有两个面板，可以通过CardLayerout方便的切换<br><img src="https://stepimagewm.how2j.cn/2735.png" alt="avatar"></p>
<h1 id="如何在SWING中使用菜单JMENU"><a href="#如何在SWING中使用菜单JMENU" class="headerlink" title="如何在SWING中使用菜单JMENU"></a>如何在SWING中使用菜单JMENU</h1><h2 id="菜单栏和菜单"><a href="#菜单栏和菜单" class="headerlink" title="菜单栏和菜单"></a>菜单栏和菜单</h2><p><img src="https://stepimagewm.how2j.cn/897.png" alt="avatar"></p>
<pre><code>// 菜单栏
JMenuBar mb = new JMenuBar();
// 菜单
JMenu mHero = new JMenu(&quot;英雄&quot;);
JMenu mItem = new JMenu(&quot;道具&quot;);
// 把菜单加入到菜单栏
mb.add(mHero);
mb.add(mItem);
// 把菜单栏加入到frame，这里用的是set而非add
f.setJMenuBar(mb);</code></pre><h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><p><img src="https://stepimagewm.how2j.cn/898.png" alt="avatar"></p>
<pre><code>JMenuBar mb = new JMenuBar();

JMenu mHero = new JMenu(&quot;英雄&quot;);
JMenu mItem = new JMenu(&quot;道具&quot;);
// 菜单项
mHero.add(new JMenuItem(&quot;近战-Warriar&quot;));
mHero.add(new JMenuItem(&quot;远程-Range&quot;));
// 分隔符
mHero.addSeparator();
mHero.add(new JMenuItem(&quot;所有-All&quot;));
mb.add(mHero);
mb.add(mItem);

f.setJMenuBar(mb);</code></pre><h1 id="SWING如何使用工具栏JTOOLBAR"><a href="#SWING如何使用工具栏JTOOLBAR" class="headerlink" title="SWING如何使用工具栏JTOOLBAR"></a>SWING如何使用工具栏JTOOLBAR</h1><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre><code>    // 菜单
    addMenu(f);
    // 工具栏
    JToolBar tb = new JToolBar();
    // 为工具栏增加按钮
    JButton b1 = new JButton(new ImageIcon(&quot;D:\\Github\\North-Box\\B.PNG&quot;));
    JButton b2 = new JButton(new ImageIcon(&quot;D:\\Github\\North-Box\\C.PNG&quot;));
    tb.add(b1);
    tb.add(b2);

    // 把工具栏放在north的位置
    f.setLayout(new BorderLayout());
    f.add(tb, BorderLayout.NORTH);

    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    f.setVisible(true);
}</code></pre><h2 id="给按钮设置提示信息"><a href="#给按钮设置提示信息" class="headerlink" title="给按钮设置提示信息"></a>给按钮设置提示信息</h2><p>当鼠标放在按钮上的时候会出现提示</p>
<pre><code>// 给按钮设置提示信息
b1.setToolTipText(&quot;坑爹英雄&quot;);</code></pre><h2 id="禁止工具栏拖动"><a href="#禁止工具栏拖动" class="headerlink" title="禁止工具栏拖动"></a>禁止工具栏拖动</h2><p>默认情况下 工具栏可以通过鼠标拖动</p>
<pre><code>//可以禁止鼠标拖动功能
setFloatable(false);</code></pre><h1 id="SWING-使用-JTABLE详解"><a href="#SWING-使用-JTABLE详解" class="headerlink" title="SWING 使用 JTABLE详解"></a>SWING 使用 JTABLE详解</h1><h2 id="基本表格"><a href="#基本表格" class="headerlink" title="基本表格"></a>基本表格</h2><p>显示一个Table需要两组数据</p>
<ol>
<li>一维数组： String[]columnNames 表示表格的标题</li>
<li>二维数组： String[][] heros 表格中的内容  </li>
</ol>
<p>默认情况下，表格的标题是不会显示出来了，除非使用了JScrollPane<br><img src="https://stepimagewm.how2j.cn/899.png" alt="avatar"></p>
<pre><code>f.setLayout(new BorderLayout());

// 表格上的title
String[] columnNames = new String[] { &quot;id&quot;, &quot;name&quot;, &quot;hp&quot;, &quot;damage&quot; };
// 表格中的内容，是一个二维数组
String[][] heros = new String[][] { { &quot;1&quot;, &quot;盖伦&quot;, &quot;616&quot;, &quot;100&quot; },
        { &quot;2&quot;, &quot;提莫&quot;, &quot;512&quot;, &quot;102&quot; }, { &quot;3&quot;, &quot;奎因&quot;, &quot;832&quot;, &quot;200&quot; } };
JTable t = new JTable(heros, columnNames);
f.add(t, BorderLayout.CENTER);</code></pre><h2 id="JScrollPane"><a href="#JScrollPane" class="headerlink" title="JScrollPane"></a>JScrollPane</h2><p>JScrollPane: 带滚动条的Panel,把table放进去就可以看到table的title<br>同样的把textarea放进去，并且textarea内容够长的话，就会看到滚动条<br><img src="https://stepimagewm.how2j.cn/902.png" alt="avatar"></p>
<pre><code>f.setLayout(new BorderLayout());

String[] columnNames = new String[] { &quot;id&quot;, &quot;name&quot;, &quot;hp&quot;, &quot;damage&quot; };
String[][] heros = new String[][] { { &quot;1&quot;, &quot;盖伦&quot;, &quot;616&quot;, &quot;100&quot; },{ &quot;2&quot;, &quot;提莫&quot;, &quot;512&quot;, &quot;102&quot; }, { &quot;3&quot;, &quot;奎因&quot;, &quot;832&quot;, &quot;200&quot; } };
JTable t = new JTable(heros, columnNames);

// 根据t创建 JScrollPane
JScrollPane sp = new JScrollPane(t);

//或则创建一个空的JScrollPane，再通过setViewportView把table放在JScrollPane中
// JScrollPane sp = new JScrollPane(t);
// sp.setViewportView(t);

// 把sp而非JTable加入到JFrame上，
f.add(sp, BorderLayout.CENTER);</code></pre><h2 id="列宽"><a href="#列宽" class="headerlink" title="列宽"></a>列宽</h2><pre><code>// 设置列宽度
t.getColumnModel().getColumn(0).setPreferredWidth(10);</code></pre><h2 id="TableModel"><a href="#TableModel" class="headerlink" title="TableModel"></a>TableModel</h2><p>首先说下TableModel的设计思想，在Model这种思想的指导下，数据和显示分离开来了。 比如对于JTable而言，有数据部分，也有显示部分(比如列宽等信息)。 数据部分，专门做一个类，叫做TableModel，就用于存放要显示的数据。</p>
<p>使用TableModel的方式存放Table需要显示的数据<br>HeroTableModel 继承AbstractTableModel ，进而实现了接口TableModel<br>在HeroTableModel 中提供一个table显示需要的所有信息</p>
<ol>
<li>getRowCount 返回一共有多少行</li>
<li>getColumnCount 返回一共有多少列</li>
<li>getColumnName 每一列的名字</li>
<li>isCellEditable 单元格是否可以修改</li>
<li>getValueAt 每一个单元格里的值</li>
</ol>
<p>当图形界面需要渲染第一个单元格的数据的时候，就会调用方法TabelModel的getValueAt(0,0) ，把返回值拿到并显示</p>
<h2 id="TableModel-与DAO结合"><a href="#TableModel-与DAO结合" class="headerlink" title="TableModel 与DAO结合"></a>TableModel 与DAO结合</h2><p><img src="https://wx1.sinaimg.cn/mw690/c2af83c2ly1ggtzffkpy6j20b408cjr9.jpg" alt="avatar"></p>
<p>通过TableModel与DAO结合显示数据库中Hero信息。<br>DAO使用HeroDAO,在TableModel中，使用从DAO返回的List作为TableModel的数据</p>
<p>只需要修改HeroTableModel，无需修改TestGUI。 这正好演绎了Model设计思想中的数据分离的好处，当只需要数据发生变化的时候，修改Model即可，界面GUI部分，不需要做任何改动</p>
<blockquote>
<p>Charactor.HeroJDBC<br>JDBC.HeroDAO<br>GUI.HeroTableModel<br>GUI.TableModelTest</p>
</blockquote>
<h2 id="TableSelectionModel"><a href="#TableSelectionModel" class="headerlink" title="TableSelectionModel"></a>TableSelectionModel</h2><p>通过table可以获取一个 TableSelectionModel，专门用于监听jtable选中项的变化<br><img src="https://stepimagewm.how2j.cn/901.png" alt="avatar"></p>
<blockquote>
<p>charactor.HeroJDBC<br>GUI.TableSectionModel</p>
</blockquote>
<h2 id="更新Table"><a href="#更新Table" class="headerlink" title="更新Table"></a>更新Table</h2><p>以新增数据到数据库中，然后更新Table为例</p>
<blockquote>
<p>JDBC.HeroDAO<br>charactor.HeroJDBC<br>GUI.HeroTableModel<br>GUI.TableUpdate</p>
</blockquote>
<h2 id="输入项验证"><a href="#输入项验证" class="headerlink" title="输入项验证"></a>输入项验证</h2><p>如果用户输入的名称为空，或者血量不是小数，在提交数据的时候都会报错。所以需要加上输入项的验证，如果输入的数据不合格，应该弹出对话框提示用户具体原因。<br><img src="https://stepimagewm.how2j.cn/932.png" alt="avatar"></p>
<blockquote>
<p>JDBC.HeroDAO<br>charactor.HeroJDBC<br>GUI.HeroTableModel<br>GUI.TableVerification</p>
</blockquote>
<h2 id="选中指定行"><a href="#选中指定行" class="headerlink" title="选中指定行"></a>选中指定行</h2><ol>
<li>table初始化后，应该默认选中第一行</li>
<li>增加数据后，也应该选中新增的这一条<br><img src="https://stepimagewm.how2j.cn/933.png" alt="avatar"><blockquote>
<p>JDBC.HeroDAO<br>charactor.HeroJDBC<br>GUI.HeroTableModel<br>GUI.TableDesignatedRow</p>
</blockquote>
</li>
</ol>
<h1 id="两种SWING下的日期控件-DATEPICKER-和JXDATEPICKER"><a href="#两种SWING下的日期控件-DATEPICKER-和JXDATEPICKER" class="headerlink" title="两种SWING下的日期控件 DATEPICKER 和JXDATEPICKER"></a>两种SWING下的日期控件 DATEPICKER 和JXDATEPICKER</h1><p>swing没有自带的日期控件，需要第三方的类,jar包可以在右侧下载</p>
<h2 id="DatePicker"><a href="#DatePicker" class="headerlink" title="DatePicker"></a>DatePicker</h2><p>本例使用 datepicker.jar 包，有一个缺点，不能设置时间，只能在创建控件的时候传入指定日期。<br>需要设置日期，请使用JXDatePicker<br><img src="https://stepimagewm.how2j.cn/943.png" alt="avatar"></p>
<h1 id="SWING中的线程"><a href="#SWING中的线程" class="headerlink" title="SWING中的线程"></a>SWING中的线程</h1><h2 id="三种线程"><a href="#三种线程" class="headerlink" title="三种线程"></a>三种线程</h2><p>在Swing程序的开发中，需要建立3种线程的概念</p>
<ol>
<li><p>初始化线程<br>初始化线程用于创建各种容器，组件并显示他们，一旦创建并显示，初始化线程的任务就结束了。</p>
</li>
<li><p>事件调度线程<br>通过事件监听的学习，我们了解到Swing是一个事件驱动的模型，所有和事件相关的操作都放是放在事件调度线程 (Event Dispatch)中进行的。比如点击一个按钮，对应的ActionListener.actionPerformed 方法中的代码，就是在事件调度线程 Event Dispatch Thread中执行的。</p>
</li>
<li><p>长耗时任务线程<br>有时候需要进行一些长时间的操作，比如访问数据库，文件复制，连接网络，统计文件总数等等。 这些操作就不适合放在事件调度线程中进行，因为占用时间久了，会让使用者感觉界面响应很卡顿。 为了保持界面响应的流畅性,所有长耗时任务都应该放在专门的 长耗时任务线程中进行</p>
</li>
</ol>
<h2 id="事件调度线程是单线程的"><a href="#事件调度线程是单线程的" class="headerlink" title="事件调度线程是单线程的"></a>事件调度线程是单线程的</h2><p>在开始讲解这3种线程之前， 要建立一个概念： 事件调度线程是单线程的。<br>为什么呢？</p>
<p>这是因为 Swing里面的各种组件类，比如JTextField,JButton 都不是线程安全的，这就意味着，如果有多个线程，那么同一个JTextField的setText方法，可能会被多个线程同时调用，这会导致同步问题以及错误数据的发生。</p>
<p>如果把组件类设计成为线程安全的，由于Swing事件调度的复杂性，就很有可能导致死锁的发生。</p>
<p>为了规避同步问题，以及降低整个Swing设计的复杂度，提高Swing的相应速度，Swing中的 事件调度线程被设计成为了单线程模式，即只有一个线程在负责事件的响应工作。</p>
<h2 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h2><p>如代码所示，同时我们在初始化一个图形界面的时候，都会直接在主方法的主线程里，直接调用如下代码来进行初始化</p>
<pre><code>new TestFrame().setVisible(true);</code></pre><p>如果是小程序这没有什么问题，如果是复杂的程序就有可能产生问题了。因为这里有两个线程在同时访问组件：1. 主线程 2. 事件调度线程。 如果是复杂的图形界面程序，就有可能出现这两个线程同时操作的情况，导致同步问题的产生。</p>
<p>为了规避这个问题的产生，创建和显示界面的工作，最好也交给事件调度线程，这样就保证了只有一个线程在访问这些组件</p>
<pre><code>SwingUtilities.invokeLater(new Runnable() {
    public void run() {
        new TestFrame().setVisible(true);
    }
});</code></pre><p>像这样，new TestFrame().setVisible(true); 这段代码就是在事件调度线程中执行了。<br>还可以使用SwingUtilities.isEventDispatchThread()来判断当前线程是否是事件调度线程</p>
<h2 id="事件调度线程"><a href="#事件调度线程" class="headerlink" title="事件调度线程"></a>事件调度线程</h2><p>以 按钮监听 中的代码为例，ActionListener.actionPerformed 中的代码，就是事件调度线程执行的。</p>
<p>可以借助SwingUtilities.isEventDispatchThread() 确认，是事件调度线程在执行相应的代码</p>
<blockquote>
<p>GUI.EventThread</p>
</blockquote>
<h2 id="长耗时任务线程"><a href="#长耗时任务线程" class="headerlink" title="长耗时任务线程"></a>长耗时任务线程</h2><p>有时候需要执行长耗时任务，比如数据库查询，文件复制，访问网络等等。</p>
<p>而这些操作一般都会在事件响应后发起，就会自动进入事件调度线程。 而事件调度线程又是单线程模式，其结果就会是在执行这些长耗时任务的时候，界面就无响应了。<br><img src="https://stepimagewm.how2j.cn/2727.png" alt="avatar"></p>
<p>如图所示，当点击第一个按钮的时候，会在其中进行一个5秒钟的任务，这个期间，第一个按钮会保持按下状态，其他按钮也无法点击，出现了无响应了状态。</p>
<p>为了解决这个问题，Swing提供了一个SwingWorker类来解决。 SwingWorker是一个抽象类，为了使用，必须实现方法 doInBackground，在doInBackground中，就可以编写我们的任务，然后执行SwingWorker的execute方法，放在专门的工作线程中去运行。</p>
<pre><code>SwingWorker worker = new SwingWorker() {
    protected Object doInBackground() throws Exception {
        //长耗时任务
        return null;
    }
};
worker.execute();</code></pre><p>SwingWorker又是如何工作的呢？<br>当SwingWorker执行execute的时候，调用默认有10根线程的线程池，执行doInBackground中的代码，通过如下代码，可以获知执行当前SwingWorder的线程名称</p>
<pre><code>System.out.println(&quot;执行这个SwingWorder的线程是：&quot; + Thread.currentThread().getName());</code></pre><blockquote>
<p>GUI.SwingWorkerTest</p>
</blockquote>
<h1 id="SWING-皮肤-LOOK-AND-FEEL"><a href="#SWING-皮肤-LOOK-AND-FEEL" class="headerlink" title="SWING 皮肤 LOOK AND FEEL"></a>SWING 皮肤 LOOK AND FEEL</h1><p>设置皮肤只需要提供一句代码,就可以把所有的组件切换成不同的风格。</p>
<pre><code>javax.swing.UIManager.setLookAndFeel(&quot;com.birosoft.liquid.LiquidLookAndFeel&quot;);</code></pre><p>注： 这句话需要加在最前面，如果已经创建了界面，再加这个有时候不能正常起作用。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/15/JAVA-Swing/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/14/JAVA-JDBC/">JDBC</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-14</span>
      <p><h1 id="JDBC基础教程"><a href="#JDBC基础教程" class="headerlink" title="JDBC基础教程"></a>JDBC基础教程</h1><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code>Statement s = c.createStatement();
String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;
s.execute(sql);</code></pre><h2 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h2><p>数据库的连接是有限资源，相关操作结束后，养成关闭数据库的好习惯<br>先关闭Statement<br>后关闭Connection</p>
<pre><code>finally {
        // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯
        // 先关闭Statement
        if (s != null)
            try {
                s.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        // 后关闭Connection
        if (c != null)
            try {
                c.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
    }</code></pre><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><pre><code>String insert = &quot;insert into hero values(&apos;1&apos;, &apos;增加一条数据&apos;, 666, 60)&quot;;
String update = &quot;update hero set name = &apos;更新&apos; where id = 205&quot;;
String delete = &quot;delete from hero where id = 204&quot;;</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code>String sql = &quot;select * from hero&quot;;
// 执行查询语句，并把结果集返回给ResultSet
ResultSet rs = s.executeQuery(sql);
while (rs.next()) {
    int id = rs.getInt(&quot;id&quot;);// 可以使用字段名
    String name = rs.getString(2);// 也可以使用字段的顺序
    float hp = rs.getFloat(&quot;hp&quot;);
    int damage = rs.getInt(4);
    System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);
}
// 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet
// rs.close();</code></pre><h2 id="SQL语句判断账号密码是否正确"><a href="#SQL语句判断账号密码是否正确" class="headerlink" title="SQL语句判断账号密码是否正确"></a>SQL语句判断账号密码是否正确</h2><ol>
<li><p>创建一个用户表，有字段name,password</p>
</li>
<li><p>插入一条数据</p>
<p> insert into user values(null,’dashen’,’thisispassword’);</p>
</li>
<li><p>SQL语句判断账号密码是否正确<br>判断账号密码的正确方式是根据账号和密码到表中去找数据，如果有数据，就表明密码正确了，如果没数据，就表明密码错误。</p>
<pre><code>String name = &quot;dashen&quot;;
String password = &quot;thisispassword1&quot;;

String sql = &quot;select * from user where name = &apos;&quot; + name +&quot;&apos; and password = &apos;&quot; + password+&quot;&apos;&quot;;

// 执行查询语句，并把结果集返回给ResultSet
ResultSet rs = s.executeQuery(sql);

if(rs.next())
    System.out.println(&quot;账号密码正确&quot;);
else
    System.out.println(&quot;账号密码错误&quot;);</code></pre></li>
</ol>
<h2 id="获取总数"><a href="#获取总数" class="headerlink" title="获取总数"></a>获取总数</h2><pre><code>String sql = &quot;select count(*) from hero&quot;;
ResultSet rs = s.executeQuery(sql);
int total = 0;
while (rs.next()) {
    total = rs.getInt(1);
}
System.out.println(&quot;表Hero中总共有:&quot; + total+&quot; 条数据&quot;);</code></pre><h1 id="在JDBC中使用预编译STATEMENT-以及它的优点"><a href="#在JDBC中使用预编译STATEMENT-以及它的优点" class="headerlink" title="在JDBC中使用预编译STATEMENT 以及它的优点"></a>在JDBC中使用预编译STATEMENT 以及它的优点</h1><h2 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h2><p>和 Statement一样，PreparedStatement也是用来执行sql语句的<br>与创建Statement不同的是，需要根据sql语句创建PreparedStatement<br>除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接</p>
<p>注： 这是JAVA里唯二的基1的地方，另一个是查询语句中的ResultSet也是基1的。</p>
<pre><code>String sql = &quot;insert into hero values(null,?,?,?)&quot;;
try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/game?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;&quot;);
    PreparedStatement ps = c.prepareStatement(sql);
) {
    ps.setString(1, &quot;提莫&quot;);
    ps.setFloat(2, 313.0f);
    ps.setInt(3, 50);
    // 执行
    ps.execute();
}</code></pre><h2 id="PreparedStatement的优点"><a href="#PreparedStatement的优点" class="headerlink" title="PreparedStatement的优点"></a>PreparedStatement的优点</h2><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>Statement 需要进行字符串拼接，可读性和维护性比较差</p>
<pre><code>String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</code></pre><p>PreparedStatement 使用参数设置，可读性好，不易犯错</p>
<pre><code>String sql = &quot;insert into hero values(null,?,?,?)&quot;;</code></pre><h3 id="性能表现"><a href="#性能表现" class="headerlink" title="性能表现"></a>性能表现</h3><p>PreparedStatement有预编译机制，性能比Statement更快</p>
<pre><code>// Statement执行10次，需要10次把SQL语句传输到数据库端
// 数据库要对每一次来的SQL语句进行编译处理
for (int i = 0; i &lt; 10; i++) {
    String sql0 = &quot;insert into hero values(null,&quot; + &quot;&apos;提莫&apos;&quot; + &quot;,&quot;
            + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;
    s.execute(sql0);
}
s.close();

// PreparedStatement 执行10次，只需要1次把SQL语句传输到数据库端，数据库对带?的SQL进行预编译
// 每次执行，只需要传输参数到数据库端
// 1. 网络传输量比Statement更小
// 2. 数据库不需要再进行编译，响应更快
for (int i = 0; i &lt; 10; i++) {
    ps.setString(1, &quot;提莫&quot;);
    ps.setFloat(2, 313.0f);
    ps.setInt(3, 50);
    ps.execute();
}</code></pre><h3 id="防止SQL注入式攻击"><a href="#防止SQL注入式攻击" class="headerlink" title="防止SQL注入式攻击"></a>防止SQL注入式攻击</h3><pre><code>// 假设name是用户提交来的数据
String name = &quot;&apos;盖伦&apos; OR 1=1&quot;;
String sql0 = &quot;select * from hero where name = &quot; + name;
// 拼接出来的SQL语句就是
// select * from hero where name = &apos;盖伦&apos; OR 1=1
// 因为有OR 1=1，所以恒成立，那么就会把所有的英雄都查出来，而不只是盖伦
// 如果Hero表里的数据是海量的，比如几百万条，把这个表里的数据全部查出来，会让数据库负载变高，CPU100%，内存消耗光，响应变得极其缓慢
System.out.println(sql0);
ResultSet rs0 = s.executeQuery(sql0);
while (rs0.next()) {
    String heroName = rs0.getString(&quot;name&quot;);
    System.out.println(heroName);
}
s.execute(sql0);

// 使用预编译Statement就可以杜绝SQL注入
ps.setString(1, name);
ResultSet rs = ps.executeQuery();
// 查不出数据出来
while (rs.next()) {
    String heroName = rs.getString(&quot;name&quot;);
    System.out.println(heroName);
}</code></pre><h2 id="execute与executeUpdate的区别"><a href="#execute与executeUpdate的区别" class="headerlink" title="execute与executeUpdate的区别"></a>execute与executeUpdate的区别</h2><h3 id="相同点：都可以执行增加，删除，修改"><a href="#相同点：都可以执行增加，删除，修改" class="headerlink" title="相同点：都可以执行增加，删除，修改"></a>相同点：都可以执行增加，删除，修改</h3><pre><code>s.execute(sqlInsert);
s.execute(sqlDelete);
s.execute(sqlUpdate);
s.executeUpdate(sqlInsert);
s.executeUpdate(sqlDelete);
s.executeUpdate(sqlUpdate);</code></pre><h3 id="不同1："><a href="#不同1：" class="headerlink" title="不同1："></a>不同1：</h3><pre><code>// 不同1：execute可以执行查询语句，然后通过getResultSet，把结果集取出来
String sqlSelect = &quot;select * from hero&quot;;
s.execute(sqlSelect);
ResultSet rs = s.getResultSet();
while (rs.next()) {
    System.out.println(rs.getInt(&quot;id&quot;));
}

// executeUpdate不能执行查询语句
// s.executeUpdate(sqlSelect);</code></pre><h3 id="不同2"><a href="#不同2" class="headerlink" title="不同2:"></a>不同2:</h3><pre><code>// execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等
boolean isSelect = s.execute(sqlSelect);
System.out.println(isSelect);

// executeUpdate返回的是int，表示有多少条数据受到了影响
String sqlUpdate = &quot;update Hero set hp = 300 where id &lt; 100&quot;;
int number = s.executeUpdate(sqlUpdate);
System.out.println(number);</code></pre><h1 id="获取自增长ID以及表的元数据"><a href="#获取自增长ID以及表的元数据" class="headerlink" title="获取自增长ID以及表的元数据"></a>获取自增长ID以及表的元数据</h1><h2 id="获取自增长id"><a href="#获取自增长id" class="headerlink" title="获取自增长id"></a>获取自增长id</h2><p>在Statement通过execute或者executeUpdate执行完插入语句后，MySQL会为新插入的数据分配一个自增长id，(前提是这个表的id设置为了自增长,在Mysql创建表的时候，AUTO_INCREMENT就表示自增长)</p>
<pre><code>CREATE TABLE hero (
id int(11) AUTO_INCREMENT,
...
}</code></pre><p>但是无论是execute还是executeUpdate都不会返回这个自增长id是多少。需要通过Statement的getGeneratedKeys获取该id<br>注： 第20行的代码，后面加了个Statement.RETURN_GENERATED_KEYS参数，以确保会返回自增长ID。 通常情况下不需要加这个，有的时候需要加，所以先加上，保险一些</p>
<pre><code>PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</code></pre><details><summary>getGeneratedKeys.java</summary>

<pre><code>ps.setString(1, &quot;盖伦&quot;);
ps.setFloat(2, 616);
ps.setInt(3, 100);

// 执行插入语句
ps.execute();

// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id
// JDBC通过getGeneratedKeys获取该id
ResultSet rs = ps.getGeneratedKeys();
if (rs.next()) {
    int id = rs.getInt(1);
    System.out.println(id);
}</code></pre></details>

<h2 id="获取表的元数据"><a href="#获取表的元数据" class="headerlink" title="获取表的元数据"></a>获取表的元数据</h2><p><font color='navyblue'>元数据概念：</font>和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p>
<details><summary>getDatabase.java</summary>

<pre><code>    try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/game?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;&quot;);) {

    // 查看数据库层面的元数据
    DatabaseMetaData dbmd = c.getMetaData();
    // 获取数据库服务器产品名称
    System.out.println(&quot;数据库产品名称:\t&quot;+dbmd.getDatabaseProductName());
    // 获取数据库服务器产品版本号
    System.out.println(&quot;数据库产品版本:\t&quot;+dbmd.getDatabaseProductVersion());
    // 获取数据库服务器用作类别和表名之间的分隔符 如test.user
    System.out.println(&quot;数据库和表分隔符:\t&quot;+dbmd.getCatalogSeparator());
    // 获取驱动版本
    System.out.println(&quot;驱动版本:\t&quot;+dbmd.getDriverVersion());
    System.out.println(&quot;可用的数据库列表：&quot;);
    // 获取数据库名称
    ResultSet rs = dbmd.getCatalogs();
    while (rs.next()) {
        System.out.println(&quot;数据库名称:\t&quot;+rs.getString(1));
    }
} </code></pre></details>

<h1 id="如何在JDBC中使用事务"><a href="#如何在JDBC中使用事务" class="headerlink" title="如何在JDBC中使用事务"></a>如何在JDBC中使用事务</h1><h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><p>在事务中的多个操作，要么都成功，要么都失败<br>通过<font color='orange'>c.setAutoCommit(false)</font>关闭自动提交<br>使用<font color='orange'>c.commit()</font>进行手动提交<br>Commit.java的代码就处于同一个事务当中，要么都成功，要么都失败<br>所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句都没有被提交。 除非两条SQL语句都是正确的。</p>
<details><summary>Commit.java</summary>

<pre><code>// 有事务的前提下
// 在事务中的多个操作，要么都成功，要么都失败
c.setAutoCommit(false);

// 加血的SQL
String sql1 = &quot;update hero set hp = hp +1 where id = 22&quot;;
s.execute(sql1);

// 减血的SQL
// 不小心写错写成了 updata(而非update)
String sql2 = &quot;updata hero set hp = hp -1 where id = 22&quot;;
s.execute(sql2);

// 手动提交
c.commit();</code></pre></details>

<h2 id="MYSQL-表的类型必须是INNODB才支持事务"><a href="#MYSQL-表的类型必须是INNODB才支持事务" class="headerlink" title="MYSQL 表的类型必须是INNODB才支持事务"></a>MYSQL 表的类型必须是INNODB才支持事务</h2><p>在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.</p>
<p>修改表的类型为INNODB的SQL：</p>
<pre><code>alter table hero ENGINE  = innodb;</code></pre><p>查看表的类型的SQL:</p>
<pre><code>show table status from how2java; </code></pre><p>不过有个前提，就是当前的MYSQL服务器本身要支持INNODB,如果不支持，请看 开启MYSQL INNODB的办法</p>
<h1 id="使用JDBC做一个ORM例子"><a href="#使用JDBC做一个ORM例子" class="headerlink" title="使用JDBC做一个ORM例子"></a>使用JDBC做一个ORM例子</h1><p>ORM=Object Relationship Database Mapping,对象和关系数据库的映射<br>简单说，一个对象，对应数据库里的一条记录</p>
<details><summary>ORM.java</summary>

<p>package Test01;</p>
<p>//导入包<br>public class ORM {<br>    public static HeroJDBC get(int id) {<br>        HeroJDBC hero = null;</p>
<pre><code>    Connection con;
    //jdbc驱动
    String driver=&quot;com.mysql.cj.jdbc.Driver&quot;;
    //这里我的数据库是cxxt
    String url=&quot;jdbc:mysql://localhost:3306/game?&amp;useSSL=false&amp;serverTimezone=UTC&quot;;
    String user=&quot;root&quot;;
    String password=&quot;&quot;;
    try {
        //注册JDBC驱动程序
        Class.forName(driver);
        //建立连接
        con = DriverManager.getConnection(url, user, password);
        if (!con.isClosed()) {
            System.out.println(&quot;数据库连接成功&quot;);
        }
        Statement stmt=con.createStatement();
        String sql = &quot;select * from hero where id = &quot; + id;

        ResultSet rs = stmt.executeQuery(sql);

    // 因为id是唯一的，ResultSet最多只能有一条记录
    // 所以使用if代替while
    if (rs.next()) {
        hero = new HeroJDBC();
        String name = rs.getString(2);
        float hp = rs.getFloat(&quot;hp&quot;);
        int damage = rs.getInt(4);
        hero.name = name;
        hero.hp = hp;
        hero.damage = damage;
        hero.id = id;
    }
    } catch (SQLException | ClassNotFoundException e) {
    // TODO Auto-generated catch block
        e.printStackTrace();
    }
        return hero;
    }

public static void main(String[] args) {
    HeroJDBC h = get(1);
    System.out.println(h.id+h.name+h.hp+h.damage);

    }
}</code></pre></details>
<details><summary>HeroJDBC.java</summary>

<pre><code>public class HeroJDBC {
//增加id属性
public int id;
public String name;
public float hp;
public int damage;</code></pre><p>}</p>
</details>

<h1 id="基于JDBC设计DAO的实例"><a href="#基于JDBC设计DAO的实例" class="headerlink" title="基于JDBC设计DAO的实例"></a>基于JDBC设计DAO的实例</h1><p><font color='navyblue'>DAO=DataAccess Object</font><br>数据访问对象</p>
<p>实际上就是运用了练习-ORM中的思路，把数据库相关的操作都封装在这个类里面，其他地方看不到JDBC的代码</p>
<h2 id="DAO接口"><a href="#DAO接口" class="headerlink" title="DAO接口"></a>DAO接口</h2><details><summary>DAO.java</summary>

<pre><code>import java.util.List;
import charactor.HeroJDBC;
public interface DAO {
    //增加
    public void add(Hero hero);
    //修改
    public void update(Hero hero);
    //删除
    public void delete(int id);
    //获取
    public Hero get(int id);
    //查询
    public List&lt;Hero&gt; list();
    //分页查询
    public List&lt;Hero&gt; list(int start, int count);
}</code></pre></details>

<h2 id="HeroDAO"><a href="#HeroDAO" class="headerlink" title="HeroDAO"></a>HeroDAO</h2><p>设计类HeroDAO，实现接口DAO</p>
<p>这个HeroDAO和答案-ORM很接近，做了几个改进：</p>
<p>1.把驱动的初始化放在了构造方法HeroDAO里：</p>
<pre><code>public HeroDAO() {
try {
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
}</code></pre><p>因为驱动初始化只需要执行一次，所以放在这里更合适，其他方法里也不需要写了，代码更简洁  </p>
<p>2.提供了一个getConnection方法返回连接<br>所有的数据库操作都需要事先拿到一个数据库连接Connection，以前的做法每个方法里都会写一个，如果要改动密码，那么每个地方都需要修改。 通过这种方式，只需要修改这一个地方就可以了。 代码变得更容易维护，而且也更加简洁。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="原理-传统方式"><a href="#原理-传统方式" class="headerlink" title="原理-传统方式"></a>原理-传统方式</h2><p>当有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。</p>
<p>创建连接和关闭连接的过程也是比较消耗时间的，当多线程并发的时候，系统就会变得很卡顿。</p>
<p>同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败。</p>
<p><img src="https://stepimagewm.how2j.cn/2654.png" alt="avatar"></p>
<h2 id="原理-使用池"><a href="#原理-使用池" class="headerlink" title="原理-使用池"></a>原理-使用池</h2><p>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。</p>
<p>如果有任何线程需要使用连接，那么就从连接池里面借用，而不是自己重新创建.<br>使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。</p>
<p>倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。</p>
<p>整个过程，这些连接都不会被关闭，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
<p><img src="https://stepimagewm.how2j.cn/2655.png" alt="avatar"></p>
<h2 id="ConnectionPool构造方法和初始化"><a href="#ConnectionPool构造方法和初始化" class="headerlink" title="ConnectionPool构造方法和初始化"></a>ConnectionPool构造方法和初始化</h2><ol>
<li><p>ConnectionPool() 构造方法约定了这个连接池一共有多少连接</p>
</li>
<li><p>在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用</p>
</li>
<li><p>getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去</p>
</li>
<li><p>returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了。</p>
</li>
</ol>
<p>注：连接池设计用到了多线程的wait和notifyAll，这些内容可以在多线程交互章节查阅学习。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/14/JAVA-JDBC/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/10/Spring%E5%AD%A6%E4%B9%A0/">JAVA后端学习规划</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-10</span>
      <p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="学习关键："><a href="#学习关键：" class="headerlink" title="学习关键："></a>学习关键：</h2><p>Spring 核心是 <font color='navyblue'>IoC 容器</font>，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。<br>理解好 IoC 后，接下来是面向<font color='navyblue'>切面编程（AOP）</font>，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。<br>其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，</p>
<h2 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h2><details>
<summary>应用程序</summary>能完成我们所需要功能的成品，比如购物网站、OA 系统。
</details>
<details>
<summary>框架</summary>能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。
</details>
<details>
<summary>非侵入式设计</summary>从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。
</details>
<details>
<summary>轻量级与重量级</summary>轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。
</details>
<details>
<summary>POJO</summary>Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。
</details>
<details>
<summary>容器</summary>在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。
</details>
<details>
<summary>控制反转</summary>即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。
</details>
<details>
<summary>Bean</summary>一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象.
</details>

<h2 id="Spring优点："><a href="#Spring优点：" class="headerlink" title="Spring优点："></a>Spring优点：</h2><p>Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。</p>
<details>
<summary>非常轻量级的容器</summary>以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。
</details>
<details>
<summary>AOP</summary>AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），_即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术_。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。
</details>
<details>
<summary>简单的数据库事务管理</summary>在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。
</details>
<details>
<summary>JDBC 抽象及 ORM（对象关系映射）框架支持</summary>Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。
</details>
<details>
<summary>灵活的 Web 层支持</summary>Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。
</details>
<details>
<summary>简化各种技术集成</summary>提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。
</details></p>
      <div class="post-button"><a class="btn" href="/2020/07/10/Spring%E5%AD%A6%E4%B9%A0/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/09/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">JAVA核心技术</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-09</span>
      <p><h1 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. 多线程</h1><h2 id="1-1-线程概念"><a href="#1-1-线程概念" class="headerlink" title="1.1. 线程概念"></a>1.1. 线程概念</h2><details><summary><font color='navyblue'>进程</font></summary>启动一个X.exe程序叫做一个进程，再启动一个Y.exe，那么就是两个进程。</details>
<details><summary><font color='navyblue'>线程</font></summary>线程是在进程内部同时进行的事，如在游戏中，A对B造成伤害，同时C在对D造成伤害</details>

<p>不使用多线程举例：</p>
<blockquote>
<p>盖伦 正在攻击 提莫, 提莫的血变成了 250<br>盖伦 正在攻击 提莫, 提莫的血变成了 200<br>盖伦 正在攻击 提莫, 提莫的血变成了 150<br>盖伦 正在攻击 提莫, 提莫的血变成了 100<br>盖伦 正在攻击 提莫, 提莫的血变成了 50<br>盖伦 正在攻击 提莫, 提莫的血变成了 0<br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 390<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 325<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 260<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 195<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 130<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 65<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 0<br>盲僧死了！  </p>
</blockquote>
<details><summary>Hero.java</summary>

<pre><code>package charcter;
import java.io.Serializable;
public class Hero{
    public String name;
    public float hp;
    public int damage;

    public void attackHero(Hero h){
        try{
            Thread.sleep(1000);
        }
        catch(InterrruptedException){
            e.printStackTrace();
        }

        h.hp-=damage;
        System.out.format(&quot;%s正在攻击%s，%s的血变成了%.0f&quot;,name,h.name,h.name,h=hp);
        if(h.isDead()){
         System.out.println(h.name+&quot;死了&quot;);
        }
    }

    public boolen isDead(){
        return 0&gt;=hp?ture:false;
    }
}   </code></pre></details>
<details><summary>attckStart.java</summary>

<pre><code>package multiplethread;
import charactor.Hero;

public class TestThread {
    public static void main(String[] args) {
        Hero gareen = new Hero();
        gareen.name = &quot;盖伦&quot;;
        gareen.hp = 616;
        gareen.damage = 50;

        Hero teemo = new Hero();
        teemo.name = &quot;提莫&quot;;
        teemo.hp = 300;
        teemo.damage = 30;

        Hero bh = new Hero();
        bh.name = &quot;赏金猎人&quot;;
        bh.hp = 500;
        bh.damage = 65;

        Hero leesin = new Hero();
        leesin.name = &quot;盲僧&quot;;
        leesin.hp = 455;
        leesin.damage = 80;

        //盖伦攻击提莫
        while(!teemo.isDead()){
            gareen.attackHero(teemo);
        }

        //赏金猎人攻击盲僧
        while(!leesin.isDead()){
            bh.attackHero(leesin);
        }
    }
}</code></pre></details>

<h2 id="1-2-多线程-继承线程类"><a href="#1-2-多线程-继承线程类" class="headerlink" title="1.2. 多线程-继承线程类"></a>1.2. 多线程-继承线程类</h2><p>使用多线程，就可以做到盖伦在攻击提莫的同时，赏金猎人也在攻击盲僧<br>设计一个类KillThread <font color='orange'>继承Thread，并且重写run方法</font></p>
<p>启动线程办法： 实例化一个KillThread对象，并且调用其,<font color='orange'>start方法启动线程,run方法并不能启动一个线程</font><br>就可以观察到 赏金猎人攻击盲僧的同时，盖伦也在攻击提莫</p>
<p>使用多线程举例： </p>
<blockquote>
<p>盖伦 正在攻击 提莫, 提莫的血变成了 250<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 390<br>盖伦 正在攻击 提莫, 提莫的血变成了 200<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 325<br>盖伦 正在攻击 提莫, 提莫的血变成了 150<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 260<br>盖伦 正在攻击 提莫, 提莫的血变成了 100<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 195<br>盖伦 正在攻击 提莫, 提莫的血变成了 50<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 130<br>盖伦 正在攻击 提莫, 提莫的血变成了 0<br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 65<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 0<br>盲僧死了！  </p>
</blockquote>
<details><summary>attackStart.java</summary>

<pre><code>/*单线程
//盖伦攻击提莫
while(!teemo.isDead()){
    gareen.attackHero(teemo);
}

//赏金猎人攻击盲僧
while(!leesin.isDead()){
    bh.attackHero(leesin);
}
 */
//多线程
KillThread killThread1 = new KillThread(gareen,teemo);
killThread1.start();
KillThread killThread2 = new KillThread(bh,leesin);
killThread2.start();</code></pre></details>
<details><summary>KillThread.java</summary>

<pre><code>import charactor.Hero;
public class KillThread extends Thread{

private Hero h1;
private Hero h2;

public KillThread(Hero h1, Hero h2){
    this.h1 = h1;
    this.h2 = h2;
}

public void run(){
    while(!h2.isDead()){
        h1.attackHero(h2);
    }
}</code></pre></details>

<h2 id="1-3-多线程-实现Runnable接口"><a href="#1-3-多线程-实现Runnable接口" class="headerlink" title="1.3. 多线程-实现Runnable接口"></a>1.3. 多线程-实现Runnable接口</h2><p>创建一个Battle类，来实现Runnable借口<br>启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p>
<pre><code>Battle battle1=new Battle(gareen,teemo);
new Thread(battle1).start();</code></pre><p>battle1对象实现了Runnable接口，所以有run方法，但是直接调用run方法并不会启动一个新的线程，所以需要借助一个线程对象的start()方法，才能启动一个新的线程<br>所以在创建Thread对象的时候，要把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了</p>
<details><summary>Battle.java</summary>

<pre><code>package Test01;
import charactor.Hero;
/*
继承线程类
public class KillThread extends Thread{

    private Hero h1;
    private Hero h2;

    public KillThread(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }
*/

//视线Runnable接口
public class Battle implements Runnable{
    private Hero h1;
    private Hero h2;

    public Battle(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }

    public void run(){
        while(!h2.isDead()){
            h1.attackHero(h2);
        }
    }
}</code></pre></details>
<details><summary>attackStart.java</summary>

<pre><code>/*单线程
//盖伦攻击提莫
while(!teemo.isDead()){
    gareen.attackHero(teemo);
}

//赏金猎人攻击盲僧
while(!leesin.isDead()){
    bh.attackHero(leesin);
}
 */
/*多线程
KillThread killThread1 = new KillThread(gareen,teemo);
killThread1.start();
KillThread killThread2 = new KillThread(bh,leesin);
killThread2.start();
 */
//继承接口
Battle battle1=new Battle(gareen,teemo);
new Thread(battle1).start();
Battle battle2=new Battle(bh,leesin);
new Thread(battle2).start();</code></pre></details>

<h2 id="1-4-创建多线程-匿名类"><a href="#1-4-创建多线程-匿名类" class="headerlink" title="1.4. 创建多线程-匿名类"></a>1.4. 创建多线程-匿名类</h2><p>使用匿名类，继承Thread,重写run方法，直接在run方法中写业务代码<br>匿名类的一个好处是可以很方便的访问外部的局部变量。</p>
<details><summary>Unname.java</summary> 

<pre><code>    /*单线程
    while(!teemo.isDead()){
        gareen.attackHero(teemo);
    }
    while(!leesin.isDead()){
        bh.attackHero(leesin);
    }
     */

    /*多线程
    KillThread killThread1 = new KillThread(gareen,teemo);
    killThread1.start();
    KillThread killThread2 = new KillThread(bh,leesin);
    killThread2.start();
     */

    /*继承接口
    Battle battle1=new Battle(gareen,teemo);
    new Thread(battle1).start();
    Battle battle2=new Battle(bh,leesin);
    new Thread(battle2).start();
    */

    //匿名类
    Thread t1= new Thread(){
        public void run(){
            //匿名类中用到外部的局部变量teemo，必须把teemo声明为final
            //但是在JDK7以后，就不是必须加final的了
            while(!teemo.isDead()){
                gareen.attackHero(teemo);
            }               
        }
    };
    t1.start();

    Thread t2= new Thread(){
        public void run(){
            while(!leesin.isDead()){
                bh.attackHero(leesin);
            }               
        }
    };
    t2.start();
}</code></pre><p>}</p>
</details>

<h1 id="2-常见的线程方法"><a href="#2-常见的线程方法" class="headerlink" title="2. 常见的线程方法"></a>2. 常见的线程方法</h1><h2 id="2-1-Thread-sleep"><a href="#2-1-Thread-sleep" class="headerlink" title="2.1. Thread.sleep()"></a>2.1. Thread.sleep()</h2><p>Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响<br>Thread.sleep(1000); 会抛出InterruptedException 中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出 InterruptedException</p>
<details><summary>sleep.java</summary>

<pre><code>public class sleep {
    public static void main(String[] args) {

        Thread t1= new Thread(){
            public void run(){
                int seconds =0;
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);
                }
            }
        };
        t1.start();
    }
}</code></pre></details>

<h2 id="3-join"><a href="#3-join" class="headerlink" title="3. join()"></a>3. join()</h2><p>首先解释一下主线程的概念<br>所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在。<br>在42行执行t.join，即表明在主线程中加入该线程。<br>主线程会等待该线程结束完毕， 才会往下运行。  </p>
<details><summary>join.java</summary>
    public class join {

<pre><code>    public static void main(String[] args) {

        final Hero gareen = new Hero();
        gareen.name = &quot;盖伦&quot;;
        gareen.hp = 616;
        gareen.damage = 50;

        final Hero teemo = new Hero();
        teemo.name = &quot;提莫&quot;;
        teemo.hp = 300;
        teemo.damage = 30;

        final Hero bh = new Hero();
        bh.name = &quot;赏金猎人&quot;;
        bh.hp = 500;
        bh.damage = 65;

        final Hero leesin = new Hero();
        leesin.name = &quot;盲僧&quot;;
        leesin.hp = 455;
        leesin.damage = 80;

        Thread t1= new Thread(){
            public void run(){
               while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }
            }
        };

        t1.start();

        //代码执行到这里，一直是main线程在运行
        try {
            //t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走
            System.out.println(&quot;join&quot;);
            t1.join();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }
            }
        };
        //会观察到盖伦把提莫杀掉后，才运行t2线程
        t2.start();
    }
}</code></pre></details>

<h2 id="3-1-线程优先级"><a href="#3-1-线程优先级" class="headerlink" title="3.1. 线程优先级"></a>3.1. 线程优先级</h2><p>当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源<br>为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源<br>同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示<br>如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码  </p>
<pre><code>t1.setPriority(Thread.MAX_PRIORITY);
t2.setPriority(Thread.MIN_PRIORITY);
t1.start();
t2.start();</code></pre><h2 id="3-2-临时暂停"><a href="#3-2-临时暂停" class="headerlink" title="3.2. 临时暂停"></a>3.2. 临时暂停</h2><p>当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源</p>
<pre><code>Thread.yield();</code></pre><h2 id="3-3-守护线程"><a href="#3-3-守护线程" class="headerlink" title="3.3. 守护线程"></a>3.3. 守护线程</h2><p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。  </p>
<p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。除此之外，还有后勤，行政等这些支持部门。  </p>
<p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。  </p>
<p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。  </p>
<p>守护线程通常会被用来做日志，性能统计等工作。</p>
<details><summary>setDaemon.java</summary>

<pre><code>public class TestThread {  
public static void main(String[] args) {

    Thread t1= new Thread(){
        public void run(){
            int seconds =0;

            while(true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);

            }              
        }
    };
    t1.setDaemon(true);
    t1.start();
}</code></pre></details>

<h1 id="4-同步"><a href="#4-同步" class="headerlink" title="4. 同步"></a>4. 同步</h1><h2 id="4-1-synchronized-同步对象概念"><a href="#4-1-synchronized-同步对象概念" class="headerlink" title="4.1. synchronized 同步对象概念"></a>4.1. synchronized 同步对象概念</h2><pre><code>Object someObject =new Object();
synchronized (someObject){
//此处的代码只有占有了someObject后才可以执行
}</code></pre><p>synchronized表示当前线程，独占 对象someObject  </p>
<p>当前线程独占了对象someObject，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。  </p>
<p>someObject 又叫同步对象，所有的对象，都可以作为同步对象。为了达到同步的效果，必须使用同一个同步对象</p>
<p>释放同步对象的方式： synchronized 块自然结束，或者有异常抛出</p>
<h2 id="4-2-线程安全的类"><a href="#4-2-线程安全的类" class="headerlink" title="4.2. 线程安全的类"></a>4.2. 线程安全的类</h2><p>如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类</p>
<p>同一时间，只有一个线程能够进入 这种类的一个实例 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p>
<h1 id="5-线程安全相关面试题"><a href="#5-线程安全相关面试题" class="headerlink" title="5. 线程安全相关面试题"></a>5. 线程安全相关面试题</h1><h2 id="5-1-HashMap和Hashtable的区别"><a href="#5-1-HashMap和Hashtable的区别" class="headerlink" title="5.1. HashMap和Hashtable的区别"></a>5.1. HashMap和Hashtable的区别</h2><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式  </p>
<p>区别1：HashMap可以存放 null；Hashtable不能存放null<br>区别2：HashMap不是线程安全的类；Hashtable是线程安全的类<br><img src="https://stepimagewm.how2j.cn/2595.png" alt="avatar"></p>
<h2 id="5-2-StringBuffer和StringBuilder的区别"><a href="#5-2-StringBuffer和StringBuilder的区别" class="headerlink" title="5.2. StringBuffer和StringBuilder的区别"></a>5.2. StringBuffer和StringBuilder的区别</h2><p>StringBuffer 是线程安全的<br>StringBuilder 是非线程安全的</p>
<p>所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuilder会更快些，如果是多线程，就需要用StringBuffer 保证数据的安全性</p>
<p>非线程安全的为什么会比线程安全的快？ 因为不需要同步，省略了些时间<br><img src="https://stepimagewm.how2j.cn/2596.png" alt="avatar"></p>
<h2 id="5-3-把非线程安全的集合转换为线程安全"><a href="#5-3-把非线程安全的集合转换为线程安全" class="headerlink" title="5.3. 把非线程安全的集合转换为线程安全"></a>5.3. 把非线程安全的集合转换为线程安全</h2><p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入一个ArrayList对象的add方法</p>
<p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p>
<blockquote>
<p>List<Integer> list1 = new ArrayList&lt;&gt;();<br>List<Integer> list2 = Collections.synchronizedList(list1);</p>
</blockquote>
<p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过工具类Collections转换为线程安全的</p>
<h2 id="5-4-JAVA-线程之间的交互-WAIT和NOTIFY"><a href="#5-4-JAVA-线程之间的交互-WAIT和NOTIFY" class="headerlink" title="5.4. JAVA 线程之间的交互 WAIT和NOTIFY"></a>5.4. JAVA 线程之间的交互 WAIT和NOTIFY</h2><p>线程之间有交互通知的需求，考虑如下情况：<br>有两个线程，处理同一个英雄。一个加血，一个减血。</p>
<p>减血的线程，发现血量=1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血</p>
<p><img src="https://stepimagewm.how2j.cn/796.png" alt="avatar"></p>
<p>解决方法：<br>在Hero类中：hurt()减血方法：当hp=1的时候，执行this.wait().<br><font color='orange'>this.wait()表示 让占有this的线程等待，并临时释放占有</font><br>进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 这样加血线程，就有机会进入recover()加血方法了。</p>
<p>recover() 加血方法：增加了血量，执行this.notify();<br><font color='orange'>this.notify() 表示通知那些等待在this的线程，可以苏醒过来了。</font> 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p>
<details><summary>Hero.java</summary>

<pre><code>public synchronized void recover() {
    hp = hp + 1;
    System.out.printf(&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;, name, name, hp);
    // 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来
    this.notify();
}

public synchronized void hurt() {
    if (hp == 1) {
        try {
            // 让占有this的减血线程，暂时释放对this的占有，并等待
            this.wait();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    hp = hp - 1;
    System.out.printf(&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;, name, name, hp);
}</code></pre></details>

<h2 id="5-5-关于wait、notify和notifyAll"><a href="#5-5-关于wait、notify和notifyAll" class="headerlink" title="5.5. 关于wait、notify和notifyAll"></a>5.5. 关于wait、notify和notifyAll</h2><p>wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法。</p>
<p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p>
<p><font color='orange'>wait()</font> 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p>
<pre><code>public synchronized void hurt() {  
。。。  
this.wait();  
。。。  
}</code></pre><p><font color='orange'>notify()</font>，通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。</p>
<pre><code>public synchronized void recover() {  
。。。  
this.notify();  
}</code></pre><p><font color='orange'>notifyAll()</font>，通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了。</p>
<h1 id="JAVA-如何开发一个自定义线程池"><a href="#JAVA-如何开发一个自定义线程池" class="headerlink" title="JAVA 如何开发一个自定义线程池"></a>JAVA 如何开发一个自定义线程池</h1><p>每一个线程的启动和结束都是比较消耗时间和占用资源的，如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。</p>
<p>为了解决这个问题，引入线程池这种设计思想，线程池的模式很像生产者消费者模式，消费的对象是一个一个的能够运行的任务。</p>
<h2 id="线程池设计思路"><a href="#线程池设计思路" class="headerlink" title="线程池设计思路"></a>线程池设计思路</h2><p>线程池的思路和生产者消费者模型是很接近的。</p>
<ol>
<li>准备一个任务容器</li>
<li>一次性启动10个消费者线程</li>
<li>刚开始任务容器是空的，所以线程都wait在上面。</li>
<li>直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被唤醒notify</li>
<li>这个消费者线程取出“任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来。</li>
<li>如果短时间内，有较多的任务加入，那么就会有多个线程被唤醒，去执行这些任务。</li>
</ol>
<p>在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程</p>
<p><img src="https://stepimagewm.how2j.cn/2600.png" alt="avatar"></p>
<h2 id="使用java自带线程池"><a href="#使用java自带线程池" class="headerlink" title="使用java自带线程池"></a>使用java自带线程池</h2><p>java提供自带的线程池，而不需要自己去开发一个自定义线程池了。</p>
<p>线程池类ThreadPoolExecutor在包<font color='orange'>java.util.concurrent</font>下</p>
<pre><code>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><p>第一个参数10 表示这个线程池初始化了10个线程在里面工作<br>第二个参数15 表示如果10个线程不够用了，就会自动增加到最多15个线程<br>第三个参数60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>第四个参数TimeUnit.SECONDS 如上<br>第五个参数 new LinkedBlockingQueue() 用来放任务的集合  </p>
<p>execute方法用于添加新的任务</p>
<h1 id="LOCK对象"><a href="#LOCK对象" class="headerlink" title="LOCK对象"></a>LOCK对象</h1><p>与synchronized类似的，lock也能够达到同步的效果</p>
<h2 id="使用Lock对象实现同步效果"><a href="#使用Lock对象实现同步效果" class="headerlink" title="使用Lock对象实现同步效果"></a>使用Lock对象实现同步效果</h2><p>Lock是一个接口，为了使用一个Lock对象，需要用到</p>
<pre><code>Lock lock = new ReentrantLock();</code></pre><p>与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。<br>与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p>
<details><summary>lock.java</summary>
    import java.text.SimpleDateFormat;  
    import java.util.Date;  
    import java.util.concurrent.locks.Lock;  
    import java.util.concurrent.locks.ReentrantLock;  

<p>public class lock {</p>
<pre><code>public static String now() {
    return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());
}

public static void log(String msg) {
    System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);
}

public static void main(String[] args) {
    Lock lock = new ReentrantLock();

    Thread t1 = new Thread() {
        public void run() {
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                lock.lock();

                log(&quot;占有对象：lock&quot;);
                log(&quot;进行5秒的业务操作&quot;);
                Thread.sleep(5000);

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log(&quot;释放对象：lock&quot;);
                lock.unlock();
            }
            log(&quot;线程结束&quot;);
        }
    };
    t1.setName(&quot;t1&quot;);
    t1.start();
    try {
        //先让t1飞2秒
        Thread.sleep(2000);
    } catch (InterruptedException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    Thread t2 = new Thread() {

        public void run() {
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                lock.lock();

                log(&quot;占有对象：lock&quot;);
                log(&quot;进行5秒的业务操作&quot;);
                Thread.sleep(5000);

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log(&quot;释放对象：lock&quot;);
                lock.unlock();
            }
            log(&quot;线程结束&quot;);
        }
    };
    t2.setName(&quot;t2&quot;);
    t2.start();
}</code></pre><p>}</p>
</details>

<h2 id="trylock方法"><a href="#trylock方法" class="headerlink" title="trylock方法"></a>trylock方法</h2><p>synchronized 是不占用到手不罢休的，会一直试图占用下去。<br>与 synchronized 的钻牛角尖不一样，Lock接口还提供了一个trylock方法。<br>trylock会在指定时间范围内试图占用，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~</p>
<p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常</p>
<details><summary>trylock.java</summary>

<pre><code>import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class trylock {

public static String now() {
    return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());
}

public static void log(String msg) {
    System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);
}

public static void main(String[] args) {
    Lock lock = new ReentrantLock();

    Thread t1 = new Thread() {
        public void run() {
            boolean locked = false;
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                locked = lock.tryLock(1,TimeUnit.SECONDS);
                if(locked){
                    log(&quot;占有对象：lock&quot;);
                    log(&quot;进行5秒的业务操作&quot;);
                    Thread.sleep(5000);
                }
                else{
                    log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {

                if(locked){
                    log(&quot;释放对象：lock&quot;);
                    lock.unlock();
                }
            }
            log(&quot;线程结束&quot;);
        }
    };
    t1.setName(&quot;t1&quot;);
    t1.start();
    try {
        //先让t1飞2秒
        Thread.sleep(2000);
    } catch (InterruptedException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    Thread t2 = new Thread() {

        public void run() {
            boolean locked = false;
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                locked = lock.tryLock(1,TimeUnit.SECONDS);
                if(locked){
                    log(&quot;占有对象：lock&quot;);
                    log(&quot;进行5秒的业务操作&quot;);
                    Thread.sleep(5000);
                }
                else{
                    log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {

                if(locked){
                    log(&quot;释放对象：lock&quot;);
                    lock.unlock();
                }
            }
            log(&quot;线程结束&quot;);
        }
    };
    t2.setName(&quot;t2&quot;);
    t2.start();
}
}</code></pre></details>

<h2 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h2><p>使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法</p>
<p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：await, signal,signalAll 方法</p>
<p>注意： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p>
<details><summary>lockCondition.java</summary>

<pre><code>import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class lockCondition{

public static String now() {
    return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());
}

public static void log(String msg) {
    System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg);
}

public static void main(String[] args) {
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    Thread t1 = new Thread() {
        public void run() {
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                lock.lock();

                log(&quot;占有对象：lock&quot;);
                log(&quot;进行5秒的业务操作&quot;);
                Thread.sleep(5000);
                log(&quot;临时释放对象 lock， 并等待&quot;);
                condition.await();
                log(&quot;重新占有对象 lock，并进行5秒的业务操作&quot;);
                Thread.sleep(5000);

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log(&quot;释放对象：lock&quot;);
                lock.unlock();
            }
            log(&quot;线程结束&quot;);
        }
    };
    t1.setName(&quot;t1&quot;);
    t1.start();
    try {
        //先让t1飞2秒
        Thread.sleep(2000);
    } catch (InterruptedException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    Thread t2 = new Thread() {

        public void run() {
            try {
                log(&quot;线程启动&quot;);
                log(&quot;试图占有对象：lock&quot;);

                lock.lock();

                log(&quot;占有对象：lock&quot;);
                log(&quot;进行5秒的业务操作&quot;);
                Thread.sleep(5000);
                log(&quot;唤醒等待中的线程&quot;);
                condition.signal();

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log(&quot;释放对象：lock&quot;);
                lock.unlock();
            }
            log(&quot;线程结束&quot;);
        }
    };
    t2.setName(&quot;t2&quot;);
    t2.start();
}</code></pre></details>

<h2 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h2><ol>
<li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p>
</li>
<li><p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p>
</li>
<li><p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p>
</li>
</ol>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/09/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/07/08/JAVA%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/">JAVA后端学习规划</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-07-08</span>
      <p><h1 id="JAVA语言学习"><a href="#JAVA语言学习" class="headerlink" title="JAVA语言学习"></a>JAVA语言学习</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p>《Java 核心技术 卷1》<br>毕向东老师的  Java 基础教程</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Maven学习：Spring相关jar包的管理<br>Junit学习：测试程序的编写及管理<br>Spring学习：《Spring实战》</p>
<h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2><p> Spring、SpringMVC、Mybatis<br> SpringBoot 和 SpringCloud。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/07/08/JAVA%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>阅读更多</a></div>
    </div>
  </div>




<footer>
  <div>
  Copyright &copy; 2019.<a href="/">North-Box</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

  </div>
</div>
</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="NorthBox"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>NorthBox</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>友链</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
